<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Apache_Flink_01</title>
    <url>/posts/Apache_Flink_01.html</url>
    <content><![CDATA[<h1 id="Apache-Flink-初探"><a href="#Apache-Flink-初探" class="headerlink" title="Apache Flink - 初探"></a>Apache Flink - 初探</h1><p>是一个框架（<strong>framework</strong>）和分布式（<strong>distributed</strong>）处理引擎（处理大数据计算），用于对无界限（<strong>unbounded</strong>）和有界限（<strong>bounded</strong>）的数据流进行有状态（<strong>stateful</strong>）的计算。<strong>Flink</strong> 被设计为在所有常见集群（<strong>cluster</strong>）环境中运行，依靠内存数据和任意规模执行计算。</p>
<a id="more"></a>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><h3 id="处理无界和有界数据"><a href="#处理无界和有界数据" class="headerlink" title="处理无界和有界数据"></a>处理无界和有界数据</h3><p>任何类型的数据都是作为事件流产生的。比如：信用卡交易，传感器测量，机器日志或者网站、移动应用上用户交互，所有的这些数据都是通过流产生的。</p>
<p>数据可以作为有界或无界形式进行处理</p>
<ol>
<li><p><strong>无界流</strong> 有起点却无终点。在生成数据时已经开始提供数据流并且不会停止下来。无界（无限制）的数据流必须连续进行处理，即，时间必须在获取后立即处理。不可能等待所有输入数据到达，因为输入是无界的，并且在任何时间点都不会完成（结束）</p>
</li>
<li><p><strong>有界流</strong> 有定义（声明好，确定好）的起点和终点。可以在执行任何计算之前提取所以数据来处理有界流。由于有界数据集始终可以进行排序，因此不需要有顺序摄取（提取）。绑定流的处理也称为批处理</p>
<p><img src="/posts/./Apache_Flink_01/bounded-unbounded.png" alt="bounded/unbounded stream"></p>
</li>
</ol>
<p style="text-align:center">图片来自<a href="https://flink.apache.org/flink-architecture.html" target="_blank" rel="noopener">官方</a></p>

<p>Apache Fink 擅长处理无界和有界的数据。精确的时间和状态控制使得 Flink 的运行时能够在无限制的流上运行任何类型的应用程序。有界流由专门为固定大小的数据集设计的算法和数据结构在内部进行处理，从而产生出色的性能。</p>
<h3 id="任何地方都可以部署应用"><a href="#任何地方都可以部署应用" class="headerlink" title="任何地方都可以部署应用"></a>任何地方都可以部署应用</h3><p>Apache Flink 是一个分布式系统，需要计算资源才能执行应用程序。Flink 与所以常见的集群资源管理器集成，但也可以设置为作为独立集群运行。</p>
<p>Flink 旨在与之前列出的每个资源管理器配合使用。这是通过特定于资源管理器的部署模式实现的，该模式运行 Flink 以其惯用的方式与每个资源管理进行交互。</p>
<p>部署 Flink 应用程序时， Flink 会根据应用程序配置的并行性自动识别所需的资源，并向资源管理器请求。如果发生故障， Flink 会通过请求新资源来替换发生故障的容器。提交或控制应用程序的所有通信均通过 <strong>REST</strong> 调用进行。这简化了 Flink 在许多环境中的集成。</p>
<h3 id="在任意规模运行应用程序"><a href="#在任意规模运行应用程序" class="headerlink" title="在任意规模运行应用程序"></a>在任意规模运行应用程序</h3><p>Flink 旨在运行任何规模的有状态流应用程序。应用程序被并行化为可能成千上万的任务，这些任务在集群分布并同时执行。因为，应用程序几乎可以利用无限数量的CPU，主内存，磁盘和网络IO。而且，Flink 易于维护非常大的应用程序状态，它的异步和增量检查点算法可确保对处理延迟的影响降至最低，同时保证一次状态一致性。</p>
<p>用户报告了在其生产环境中运行的 Flink 应用程序的可扩展性数字，例如：</p>
<ul>
<li>每天处理数万亿事件的应用程序</li>
<li>维护多个TB状态的应用程序</li>
<li>以及在数千内核上运行的应用程序</li>
</ul>
<p>利用内存性能</p>
<p>有状态 Flink 应用程序针对本地状态访问进行了优化。任务状态始终在内存中，或者，如果状态超出可用内存，则始终保持在访问有效的磁盘数据结构中。因此，任务通过访问通常在内存中的本地状态执行所有计算，从而产生非常低的处理延迟。Flink 通过定期将本地状态异步指向持久性存储，从而确保在故障情况下一次准确的状态一致性。</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>Apache Flink 是用于无限制和有限制的数据流上的有状态计算的框架。Flink 在不同的抽象别提供了多个 API，并为常见用例提供了专用的库。</p>
<h3 id="流应用程序的构建块"><a href="#流应用程序的构建块" class="headerlink" title="流应用程序的构建块"></a>流应用程序的构建块</h3><p>流处理框架可以构建并执行的应用程序类有框架控制流，状态和时间的程度定义。在下文中，我们将描述用于流处理应用程序的这些构建块，并说明 Flink 的处理方法。</p>
<p>Streams 流</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>Apache Flink</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter-01</title>
    <url>/posts/Flutter-01.html</url>
    <content><![CDATA[<p>最近看到Flutter，所以准备玩下这个~</p>
<h3 id="前期的一些坑"><a href="#前期的一些坑" class="headerlink" title="前期的一些坑"></a>前期的一些坑</h3><h4 id="准备的东西"><a href="#准备的东西" class="headerlink" title="准备的东西"></a>准备的东西</h4><ol>
<li>Android Studio（个人推荐）或者Visual Studio Code（VS Code）</li>
<li>Android SDK（使用Android Studio中的SDK Manager下载，需要修改代理设置）</li>
<li>一部手机（或者使用模拟器）</li>
<li>Flutter SDK</li>
<li>Flutter镜像环境配置</li>
</ol>
<a id="more"></a>
<h4 id="新建Flutter项目后"><a href="#新建Flutter项目后" class="headerlink" title="新建Flutter项目后"></a>新建Flutter项目后</h4><h5 id="更改为阿里镜像"><a href="#更改为阿里镜像" class="headerlink" title="更改为阿里镜像"></a>更改为阿里镜像</h5><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">buildscript {</span><br><span class="line">    ...</span><br><span class="line">    repositories {</span><br><span class="line"><span class="addition">+       maven{ url 'https://maven.aliyun.com/repository/google'}</span></span><br><span class="line"><span class="addition">+       maven{ url 'https://maven.aliyun.com/repository/gradle-plugin'}</span></span><br><span class="line"><span class="addition">+       maven{ url 'https://maven.aliyun.com/repository/public'}</span></span><br><span class="line"><span class="addition">+       maven{ url 'https://maven.aliyun.com/repository/jcenter'}</span></span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ....</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">allprojects {</span><br><span class="line">    repositories {</span><br><span class="line"><span class="addition">+       maven{ url 'https://maven.aliyun.com/repository/google'}</span></span><br><span class="line"><span class="addition">+       maven{ url 'https://maven.aliyun.com/repository/gradle-plugin'}</span></span><br><span class="line"><span class="addition">+       maven{ url 'https://maven.aliyun.com/repository/public'}</span></span><br><span class="line"><span class="addition">+       maven{ url 'https://maven.aliyun.com/repository/jcenter'}</span></span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h5 id="修改gradle的仓库地址"><a href="#修改gradle的仓库地址" class="headerlink" title="修改gradle的仓库地址"></a>修改gradle的仓库地址</h5><p>包管理-Dart,下载依赖会存储在 Flutter SDK 安装路径下</p>
<h5 id="关于调试"><a href="#关于调试" class="headerlink" title="关于调试"></a>关于调试</h5><p>控制台是调试程序必须要看的一个辅助工具，控制台有两个：一个是调试Android程序的 LogCat调试台，另一个是Flutter里面自带的Run控制台。</p>
<p>Flutter Toggle Debug Painting 这个还是很重要，可以在不同机器上看到布局情况。</p>
<p><img src="/posts/./flutter-01\1555343142313.png" alt="1555343142313"></p>
<h3 id="关于以前的一些事（一些废话）"><a href="#关于以前的一些事（一些废话）" class="headerlink" title="关于以前的一些事（一些废话）"></a>关于以前的一些事（一些废话）</h3><p>​        在实习阶段的时候，大佬让我看看<code>APICloud</code>和<code>Ionic</code>。因为接下来的工作内容是，是将之前的应用移植到移动端中，并且跨越两个平台，再做一些客户定制的功能。最后，小组选定用<code>APICloud</code>。而在之后的工作，我也只是将<code>APICloud</code>上的一些现有的官方模块整理好，并实现前端调用的接口，像是地图，图片剪辑，文件管理等。移植的工作全是大佬来完成。</p>
<p>​        原来开发移动端APP还可以这样。总体效果还是不错的，虽然在一些模块中感觉就是把浏览器嵌入到APP中（其实后来才知道是webview）。<code>APICloud</code>总得来说还是不错的，如果要在短期内做出一个轻便的应用，但是又没有移动端开发经验的话。</p>
<p>​        在之后的学习中，了解到一些其他的开发移动端的姿势。</p>
<ol>
<li>原生开发</li>
<li>Hybrid混合式<ol>
<li>APICloud (APPCan)</li>
<li>Ionic</li>
</ol>
</li>
<li>React Native</li>
<li>自绘UI+原生(Flutter) </li>
</ol>
<p>​        到了现在，Flutter出现了，我觉得这是个不错的选择。Flutter是什么呢？</p>
<p>​        Flutter是谷歌的移动UI框架，可以快速在iOS和Android上构建高质量的原生用户界面<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> 。主要是为了解决跨平台问题，兼顾Android和IOS平台，即使呈现给用户的效果一样，但是具体实现上却是千差万别（有点夸张）。同时在设计方面使用 <a href="https://material.io/" target="_blank" rel="noopener">Material Design</a>  。我觉得非常有趣，可以一试。或者你看看在B站上关于<code>Material Design</code>的宣传 <a href="https://www.bilibili.com/video/av40925939" target="_blank" rel="noopener">视频</a>。 </p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">摘自关于Flutter的介绍:https://flutterchina.club</span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;">移动开发技术简介: https://book.flutterchina.club/chapter1/mobile_development_intro.html</span><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">3.</span><span style="display: inline-block; vertical-align: top;">flutter vs 其他跨平台開發工具:https://www.bilibili.com/video/av44447707/?p=1</span><a href="#fnref:3" rev="footnote"> ↩</a></li></ol></div></div><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>Flutter</tag>
        <tag>app</tag>
      </tags>
  </entry>
  <entry>
    <title>【译】Flutter中的Bottom sheets</title>
    <url>/posts/flutter-02.html</url>
    <content><![CDATA[<p>作者： <a href="https://flutterdoc.com/@hitherejoe?source=post_page-----ec05c90453e7----------------------" target="_blank" rel="noopener">Joe Birch</a></p>
<p>原文地址：<a href="https://flutterdoc.com/bottom-sheets-in-flutter-ec05c90453e7" target="_blank" rel="noopener">https://flutterdoc.com/bottom-sheets-in-flutter-ec05c90453e7</a></p>
<p><img src="/posts/./flutter-02\header.png" alt="1_PXlGmKUbyn0cO8E_ncM6Rw"></p>
<p><code>Bottom sheets</code>（底部菜单或底部页面）是（移动设备）屏幕底部展示内容给用户的视图（widget） — 这样或许可以促进与用户进一步的交互或展示其他内容的一些形式。通常固定在屏幕的底部，并方便用户隐藏。在Flutter中，有2种开箱即用（声明式）的<code>bottom sheet widget</code>,分别是 <strong>Persistent Bottom Sheet</strong> 和 <strong>Modal Bottom Sheet</strong>  — 那么我们来看下这些widget是如何运行，同时在我们的apps中如何去使用它们。</p>
<a id="more"></a>
<p>如果你对<code>Bottom Sheets</code>还不了解的话，我们可以从<code>material design</code>规范中拿一个例子来说明下：</p>
<p><img src="/posts/./flutter-02\example.png" alt="1_0yFbm2vwVdEzc91tJ0r2jw"></p>
<p>在图的左边是一个<code>persisten botttom sheet</code>，在这个案例中，它可以上下滑动来弹出并展示当前播放的歌曲 — 在视图外保持持久状态。在图右边，我们有一个<code>modal bottom sheet</code>，通常用于对屏幕显示内容进行交互。</p>
<h1 id="Modal-Bottom-Sheet（模态底部菜单）"><a href="#Modal-Bottom-Sheet（模态底部菜单）" class="headerlink" title="Modal Bottom Sheet（模态底部菜单）"></a>Modal Bottom Sheet（模态底部菜单）</h1><p>当一个<code>modal bottom sheet</code>展示时，它可以看做是一个阻止窗口组件 — 这意味着阻止用户在应用当前页面的其他地方进行操作。这可以视为向用户展示某种形式的菜单或对话框的替代方案。点击<code>back</code>或是点击除了底部菜单以外的地方会从视图中将它消除。</p>
<p>我们可以通过<code>showModalBottomSheet</code>方法来创建一个底部菜单，完成此操作后，再使用Navigator将菜单作为路由推到应用的navigator中。</p>
<figure class="highlight dart"><table><tbody><tr><td class="code"><pre><span class="line">showModalBottomSheet&lt;<span class="keyword">void</span>&gt;(context: context,</span><br><span class="line">    builder: (BuildContext context) {</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Column(</span><br><span class="line">        mainAxisSize: MainAxisSize.min,</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          <span class="keyword">new</span> ListTile(</span><br><span class="line">            leading: <span class="keyword">new</span> Icon(Icons.music_note),</span><br><span class="line">            title: <span class="keyword">new</span> Text(<span class="string">'Music'</span>),</span><br><span class="line">            onTap: () =&gt; ...,          </span><br><span class="line">          ),</span><br><span class="line">          <span class="keyword">new</span> ListTile(</span><br><span class="line">            leading: <span class="keyword">new</span> Icon(Icons.photo_album),</span><br><span class="line">            title: <span class="keyword">new</span> Text(<span class="string">'Photos'</span>),</span><br><span class="line">            onTap: () =&gt; ...,          </span><br><span class="line">          ),</span><br><span class="line">          <span class="keyword">new</span> ListTile(</span><br><span class="line">            leading: <span class="keyword">new</span> Icon(Icons.videocam),</span><br><span class="line">            title: <span class="keyword">new</span> Text(<span class="string">'Video'</span>),</span><br><span class="line">            onTap: () =&gt; ...,          </span><br><span class="line">          ),</span><br><span class="line">        ],</span><br><span class="line">      );</span><br><span class="line">   });</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>
<p>在我们的应用中运行以上的代码，然后我们会发现在屏幕的底部会出现底部菜单。</p>
<p><img src="/posts/./flutter-02\modalBottomSheet.png" alt="1_sy8FUJKzUBrjtaWhdKefkQ"></p>
<p>关于<code>showModalBottomSheet</code>中的<code>builder</code>参数，我们只需返回要在<code>bottom sheet</code>中显示的<code>widget</code>。这根据你的需求而定，但是在本例中我使用了<code>Column</code>来展示一些<code>ListTile</code>实例的集合，来呈现出以上的符合<code>material</code>指南中的视图。当点击<code>bottom sheet</code>之外的地方时，对话框将被撤销并在视图中完全删除。因为这是一个<strong>modal</strong><code>bottom sheet</code>，没有持久状态的存在。它可以在当前上下文中调用某种形式的操作。</p>
<p><strong>注意</strong>：如果使用<code>Column</code>来展示表单的内容，则必须使用<code>mainAxisSize</code>中的<code>MainAxisSize.min</code>来确保包装内容。</p>
<h1 id="Persistent-Bottom-Sheet（持久底板）"><a href="#Persistent-Bottom-Sheet（持久底板）" class="headerlink" title="Persistent Bottom Sheet（持久底板）"></a>Persistent Bottom Sheet（持久底板）</h1><p>当展示一个持久的底部菜单时，通常用于显示应用当前页面所相符的内容 。这些<code>sheet</code>经常被用于显示上下文来关联内容，同时将用户的<code>路由</code>保持在当前。点击<strong>返回</strong>或者<strong>将菜单向下弹出</strong>都会使得<code>sheet</code>向下弹出直到提示用户操作。然而，此时它处于准备以便于用户再次弹出。</p>
<p>当我们想要使用持久性底层时，我们需要做一些不同的事情。 首先，我们需要创建一个新的<code>GlobalKey</code>实例，以便我们可以访问<code>Scaffold</code>，它将用于显示我们的持久底页。</p>
<figure class="highlight dart"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> GlobalKey&lt;ScaffoldState&gt; _scaffoldKey = <span class="keyword">new</span> </span><br><span class="line">        GlobalKey&lt;ScaffoldState&gt;();</span><br></pre></td></tr></tbody></table></figure>
<p>然后在<code>Scaffold</code>中这样设置:</p>
<figure class="highlight dart"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Scaffold(</span><br><span class="line">  key: _scaffoldKey,</span><br><span class="line">  ....</span><br></pre></td></tr></tbody></table></figure>
<p>之后我们使用这个<code>Scaffold</code>键值来获取当前状态并展示<code>persistent bottom sheet</code>:</p>
<figure class="highlight dart"><table><tbody><tr><td class="code"><pre><span class="line">_scaffoldKey.currentState</span><br><span class="line">    .showBottomSheet&lt;<span class="built_in">Null</span>&gt;((BuildContext context) {</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Container(</span><br><span class="line">      child: <span class="keyword">new</span> Column(</span><br><span class="line">    mainAxisSize: MainAxisSize.min,</span><br><span class="line">    children: &lt;Widget&gt;[</span><br><span class="line">      <span class="keyword">new</span> Padding(</span><br><span class="line">          padding: <span class="keyword">const</span> EdgeInsets.all(<span class="number">16.0</span>),</span><br><span class="line">          child: <span class="keyword">new</span> Text(</span><br><span class="line">            <span class="string">'Persistent header for bottom bar!'</span>,</span><br><span class="line">            textAlign: TextAlign.left,</span><br><span class="line">          )),</span><br><span class="line">      <span class="keyword">new</span> Text(</span><br><span class="line">        <span class="string">'Then here there will likely be some other content '</span></span><br><span class="line">            <span class="string">'which will be displayed within the bottom bar'</span>,</span><br><span class="line">        textAlign: TextAlign.left,</span><br><span class="line">      ),</span><br><span class="line">    ],</span><br><span class="line">  ));</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>
<p>我们需要这个额外的的设置，因为持久的底部表格在工作方式上与模态式会有一些不同。模态式的底部表单本质上是一个阻止对话框，所以它可以在屏幕上向用户展示。但是因为持久式的底部菜单需要滑入和滑出视图，对当前的上下文进行补充，所以需要知道当前显示它的<code>Scaffold</code>。</p>
<p>当说到底部表单的内容时，就像模态式底部页，我们需要提供一个用于显示的组件。</p>
<p><img src="/posts/./flutter-02\persistent.png" alt="1_sy8FUJKzUBrjtaWhdKefkQ"></p>
<p>这仅有的区别是，我们需要注意所展示的内容。正如在这篇文章最开始所展示<code>materail design</code>例图那样，持久性底页始终对用户可见，即使它未被展开。因此，你可能想将一些标题内容在底页展开时保留在视图中，或者转换为其他形式的内容来提供用户进一步的操作。</p>
<p>另一方面，你应该看到了持久性的底页不会覆盖它的背景，因为不需要阻止用户其他操作。与模态式底页不同，它可以通过在窗口小部件上执行垂直滑动操作来上下弹出。</p>
<p><img src="/posts/./flutter-02\persistent.gif" alt="1_sy8FUJKzUBrjtaWhdKefkQ"></p>
<p>当我们调用<code>showBottomSheet</code>函数时，会获得一个<code>PersistentBottomSheetController</code>实例，我们可以使用这个控制器来关闭这个底页：</p>
<figure class="highlight dart"><table><tbody><tr><td class="code"><pre><span class="line">PersistentBottomSheetController controller = </span><br><span class="line">        _scaffoldKey.currentState.showBottomSheet...</span><br><span class="line">controller.close();</span><br></pre></td></tr></tbody></table></figure>
<p>我们也可以监听之后控制器传来的关闭事件，当底页关闭时，我们就可以做一些操作：</p>
<figure class="highlight dart"><table><tbody><tr><td class="code"><pre><span class="line">controller.closed.then(...)</span><br></pre></td></tr></tbody></table></figure>
<p>我希望这篇文章能够进一步深入了解如何在应用程序中实现底页，以及哪一个是正确的。 如果您有任何问题或意见，请联系！</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>Flutter</tag>
        <tag>app</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义Hexo与主题NexT</title>
    <url>/posts/Hello-Hexo-2.html</url>
    <content><![CDATA[<p>这里将记录关于<code>Hexo</code>一些东西，关于<code>NexT</code>主题，还有修改博客的东西都记录在这里。</p>
<h2 id="Hexo的文件结构"><a href="#Hexo的文件结构" class="headerlink" title="Hexo的文件结构"></a>Hexo的文件结构</h2><p>使用<code>hexo init</code>初始化文件夹，并在安装好所需的依赖，其文件夹的结构：</p>
<p><img src="/posts/./Hello-Hexo-2\hexo_folders.png" alt="hexo_folders"></p>
<ol>
<li><p><code>.deploy_git</code>：是上传到<code>GitHub</code>中，如果你想添加一些额外东西的话，可以到下面的<code>public</code>文件夹中进行添加，然后在使用<code>hexo d -g</code>部署到<code>GitHub</code>中。</p>
</li>
<li><p><code>node_modules</code>：是<code>Hexo</code>运行时需要的一些依赖文件。</p>
</li>
<li><p><code>public</code>：和<code>.deploy_git</code>一样，生成的静态文件，只不过不用上传而已</p>
</li>
<li><p><code>scaffolds</code>：是一些模板文件，可以预先定义一些博文的模板，通用的格式</p>
</li>
<li><p><code>source</code>：我们编辑的<code>md</code>文件生成对应的静态文件就在这里，还有生成的一些分类文件夹也在这里。</p>
</li>
<li><p><code>themes</code>：存放主题文件的地方。</p>
</li>
<li><p><code>.gitigonre</code>：过滤上传的文件</p>
</li>
<li><p><code>_config.yml</code>：站点配置文件</p>
</li>
<li><p><code>db.json</code>：Hexo生成的缓存文件</p>
</li>
<li><p><code>package-lock.json</code>和<code>package.json</code>：类型Maven项目的pom.xml，目的是记录当前项目安装哪些依赖。</p>
</li>
</ol>
<a id="more"></a>
<h3 id="站点配置文件：-config-yml"><a href="#站点配置文件：-config-yml" class="headerlink" title="站点配置文件：_config.yml"></a>站点配置文件：_config.yml</h3><h4 id="网站设置"><a href="#网站设置" class="headerlink" title="网站设置"></a>网站设置</h4><figure class="highlight yml"><figcaption><span>文件地址:博客/_confg.yml</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">网站标题</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">网站副标题</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">网站描述，这里的作用是便于搜索引擎找到你的博客</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">作者</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">网站使用的语言</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">时区，默认是电脑使用的时区</span></span><br></pre></td></tr></tbody></table></figure>
<h4 id="网址"><a href="#网址" class="headerlink" title="网址"></a>网址</h4><figure class="highlight yml"><figcaption><span>站点配置:site/_confg.yml</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">url:</span> <span class="string">网址</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">网站根目录，默认为：</span> <span class="string">/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">文章的永久链接格式，默认为：</span> <span class="string">:year/:month/:day/:title/</span></span><br><span class="line"><span class="attr">permalink_defaults:</span> <span class="string">永久链接中各部分的默认值</span></span><br></pre></td></tr></tbody></table></figure>
<p>注：若是把博客网站放在子目录中，比如：<code>http://yoursite.com/blog</code>，则需要将<code>root</code>改为<code>/blog/</code></p>
<h5 id="permalink-生成的链接"><a href="#permalink-生成的链接" class="headerlink" title="permalink  - 生成的链接"></a>permalink  - 生成的链接</h5><p>​    按照默认的生成规则，文字链接的格式是 <em>时间  +文章名</em> 这样的形式。如果你的文章名是中文的话，就会造成一定程度上面的困扰，也不利于<code>SEO</code>。</p>
<p>​    所以可以借助<code>hexo-abbrlink</code>，修改生成规则，减少链接的层级。 但是对<code>hexo-asset-image</code>有影响，需要在文章头部修改<code>abbrlink</code>。安装命令如下：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ npm install hexo-abbrlink --save</span><br></pre></td></tr></tbody></table></figure>
<p>之后修改站点配置文件：</p>
<figure class="highlight yml"><figcaption><span>站点配置:site/_confg.yml</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">post/:abbrlink.html</span> </span><br><span class="line"><span class="attr">abbrlink:</span></span><br><span class="line"><span class="attr">  alg:</span> <span class="string">crc32</span> <span class="comment"># 算法</span></span><br><span class="line"><span class="attr">  rep:</span> <span class="string">dec</span> <span class="comment"># 进制</span></span><br></pre></td></tr></tbody></table></figure>
<p>重新部署后，文章的<code>abbrlink</code>由算法生成，如下形式的：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">http://localhost:4000/post/17e96663.html</span><br><span class="line">http://localhost:4000/post/17e96663.html</span><br></pre></td></tr></tbody></table></figure>
<p>同时，也可以直接修改<code>abbrlink</code>的值，直接自定义</p>
<figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line"><span class="deletion">- abbrlink: '17e96663`</span></span><br><span class="line"><span class="addition">+ abbrlink: 'Hello-World`</span></span><br></pre></td></tr></tbody></table></figure>
<h5 id="hexo-asset-image-amp-图片"><a href="#hexo-asset-image-amp-图片" class="headerlink" title="hexo-asset-image&amp; 图片"></a>hexo-asset-image&amp; 图片</h5><p>关于<code>hexo-asset-image</code>，原本引用图片的命令是：</p>
<figure class="highlight markdown"><table><tbody><tr><td class="code"><pre><span class="line">![<span class="string">代替文字</span>](<span class="link">图片名.jpg</span>)</span><br><span class="line">![<span class="string">代替文字</span>](<span class="link">./md文件名/图片</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>使用<code>hexo-abbrlink</code>插件，可以自定义<code>abbrlink</code>的值，来简化引入图片</p>
<p>如果你对这个插件比较感兴趣，可以去看下<a href="https://github.com/rozbo/hexo-abbrlink" target="_blank" rel="noopener">hexo-abbrlink的官网</a>。</p>
<hr>

<h2 id="改造Hexo博客todoList1"><a href="#改造Hexo博客todoList1" class="headerlink" title="改造Hexo博客todoList1"></a>改造Hexo博客todoList<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></h2><div class="note info no-icon"><p>个性化自己的博客，注：当前使用的主题是<strong>NexT</strong>，所以是针对NexT</p></div>



<p>NexT 仓库地址 <a href="https://github.com/theme-next" target="_blank" rel="noopener">https://github.com/theme-next</a></p>
<h3 id="核心配置"><a href="#核心配置" class="headerlink" title="核心配置"></a>核心配置</h3><h4 id="override"><a href="#override" class="headerlink" title="override"></a>override</h4><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line"># 用于更新 NexT 项目</span><br><span class="line"><span class="deletion">- override: false</span></span><br><span class="line"><span class="addition">+ override: true</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="网站信息设置"><a href="#网站信息设置" class="headerlink" title="网站信息设置"></a>网站信息设置</h3><h4 id="favicon-站点图标"><a href="#favicon-站点图标" class="headerlink" title="favicon - 站点图标"></a>favicon - 站点图标</h4><p>先选好一张图片，然后到<a href="https://realfavicongenerator.net" target="_blank" rel="noopener">这里</a>生成相应的图片，然后把图片放在主题的资源文件夹<code>/themes/next/source/images/</code>下面，我新建了一个<code>favicon</code>文件夹用来存放站点图标</p>
<figure class="highlight yml"><figcaption><span>文件位置：theme/next/_config.yml</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">favicon:</span></span><br><span class="line"><span class="attr">  small:</span> <span class="string">/images/favicon/favicon-16x16-next.png</span></span><br><span class="line"><span class="attr">  medium:</span> <span class="string">/images/favicon/favicon-32x32-next.png</span></span><br><span class="line"><span class="attr">  apple_touch_icon:</span> <span class="string">/images/apple-touch-icon-next.png</span></span><br><span class="line"><span class="attr">  safari_pinned_tab:</span> <span class="string">/images/logo.svg</span></span><br><span class="line">  <span class="comment">#android_manifest: /images/manifest.json</span></span><br><span class="line">  <span class="comment">#ms_browserconfig: /images/browserconfig.xml</span></span><br></pre></td></tr></tbody></table></figure>
<h4 id="keywords-默认关键词"><a href="#keywords-默认关键词" class="headerlink" title="keywords - 默认关键词"></a>keywords - 默认关键词</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"># Set default keywords (Use a comma to separate)</span><br><span class="line">keywords: "Something Good"</span><br></pre></td></tr></tbody></table></figure>
<h4 id="rss-订阅设置"><a href="#rss-订阅设置" class="headerlink" title="rss - 订阅设置"></a>rss - 订阅设置</h4><p>无修改</p>
<h4 id="footer-页脚"><a href="#footer-页脚" class="headerlink" title="footer - 页脚"></a>footer - 页脚</h4><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">footer:</span><br><span class="line"><span class="addition">+  # 建站年份</span></span><br><span class="line"><span class="addition">+  since: 2018</span></span><br><span class="line"><span class="addition">+  # 年份后面的图标，为 Font Awesome 图标</span></span><br><span class="line"><span class="addition">+  # https://fontawesome.com/v4.7.0/icons/</span></span><br><span class="line"><span class="addition">+  icon: rocket</span></span><br><span class="line"><span class="addition">+  # 作者</span></span><br><span class="line"><span class="addition">+  copyright: </span></span><br><span class="line">  # 是否展示Hexo的地址</span><br><span class="line">  powered: true</span><br><span class="line"></span><br><span class="line">  # 是否展示使用Hexo的主题</span><br><span class="line">  theme:</span><br><span class="line">    # Theme &amp; scheme info link (Theme - NexT.scheme).</span><br><span class="line">    enable: true</span><br><span class="line">    # Version info of NexT after scheme info (vX.X.X).</span><br><span class="line">    version: true</span><br><span class="line">   </span><br><span class="line">  # 自定义文本</span><br><span class="line">  #custom_text: 'Hello'</span><br></pre></td></tr></tbody></table></figure>
<h3 id="SEO-设置"><a href="#SEO-设置" class="headerlink" title="SEO 设置"></a>SEO 设置</h3><p>无修改</p>
<h3 id="菜单设置"><a href="#菜单设置" class="headerlink" title="菜单设置"></a>菜单设置</h3><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || home</span><br><span class="line">  about: /about/ || vcard</span><br><span class="line">  tags: /tags/ || tags</span><br><span class="line">  archives: /archives/ || calculator</span><br><span class="line">  </span><br><span class="line"><span class="addition">+ #  开启图标</span></span><br><span class="line">menu_icons:</span><br><span class="line">  enable: true</span><br></pre></td></tr></tbody></table></figure>
<h3 id="主题方案选择"><a href="#主题方案选择" class="headerlink" title="主题方案选择"></a>主题方案选择</h3> <figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line"># Schemes</span><br><span class="line">#scheme: Muse</span><br><span class="line">#scheme: Mist</span><br><span class="line"><span class="addition">+ scheme: Pisces</span></span><br><span class="line">#scheme: Gemini</span><br></pre></td></tr></tbody></table></figure>
<h3 id="侧边栏设置"><a href="#侧边栏设置" class="headerlink" title="侧边栏设置"></a>侧边栏设置</h3><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line"><span class="addition">+ # 社交链接</span></span><br><span class="line"><span class="addition">+ social:</span></span><br><span class="line"><span class="addition">+   GitHub: https://github.com/yourname || github</span></span><br><span class="line"></span><br><span class="line"># Blog rolls</span><br><span class="line"><span class="addition">+ # 侧栏友链设置</span></span><br><span class="line"><span class="addition">+ links_icon: globe</span></span><br><span class="line"><span class="addition">+ links_title: 神奇的链接</span></span><br><span class="line"><span class="addition">+ #links_layout: block</span></span><br><span class="line"><span class="addition">+ links_layout: inline</span></span><br><span class="line"><span class="addition">+ links:</span></span><br><span class="line"><span class="addition">+	UserA: xxxx</span></span><br><span class="line"><span class="addition">+	UserB: ssss</span></span><br><span class="line"></span><br><span class="line"># 侧边栏头像设置</span><br><span class="line"># Sidebar Avatar</span><br><span class="line"># in theme directory(source/images): /images/avatar.gif</span><br><span class="line"># in site  directory(source/uploads): /uploads/avatar.gif</span><br><span class="line"># 将头像放在blog/source/uploads中（新建uploads）</span><br><span class="line"><span class="addition">+ avatar: /uploads/logo.jpg</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="emoji表情（有问题）"><a href="#emoji表情（有问题）" class="headerlink" title="emoji表情（有问题）"></a>emoji表情（有问题）</h3><p>先安装<code>hexo-filter-github-emojis</code></p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">npm install hexo-filter-github-emojis --save</span><br></pre></td></tr></tbody></table></figure>
<p>安装完成后，修改站点配置文件</p>
<figure class="highlight diff"><figcaption><span>文件位置：~/blog/_config.yml</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="addition">+ # emoji表情支持</span></span><br><span class="line"><span class="addition">+ githubEmojis:</span></span><br><span class="line"><span class="addition">+  enable: true</span></span><br><span class="line"><span class="addition">+  idName: github-emoji</span></span><br><span class="line"><span class="addition">+  unicode: false</span></span><br><span class="line"><span class="addition">+  styles:</span></span><br><span class="line"><span class="addition">+  localEmojis:</span></span><br></pre></td></tr></tbody></table></figure>
<p>接着我们要修改下这个插件，这里和<a href="https://reuixiy.github.io/technology/computer/computer-aided-art/2017/06/09/hexo-next-optimization.html#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-emoji" target="_blank" rel="noopener">reuixiy</a>就不同了</p>
<figure class="highlight diff"><figcaption><span>文件位置：~/blog/node_modules/hexo-filter-github-emojis/index.js</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">if (options.inject) {</span><br><span class="line">      $('body').append(`&lt;script&gt;</span><br><span class="line"><span class="deletion">-        document.querySelectorAll('.${options.className}')</span></span><br><span class="line"><span class="addition">+        document.querySelectorAll('#${options.className}')</span></span><br><span class="line">          .forEach(el =&gt; {...});</span><br><span class="line">      &lt;/script&gt;`)</span><br><span class="line">}</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line"><span class="deletion">- return `&lt;span class="${options.className}" style="${styles.join(';')}" data-src="${emojis[name].src}"&gt;${codepoints}&lt;/span&gt;`</span></span><br><span class="line"><span class="addition">+ return `&lt;span id="${options.className}" style="${styles.join(';')}" data-src="${emojis[name].src}"&gt;${codepoints}&lt;/span&gt;`</span></span><br></pre></td></tr></tbody></table></figure>
<p>最后补点东西</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 自定义emoji样式</span><br><span class="line">img#github-emoji {</span><br><span class="line">    margin: 0px;</span><br><span class="line">    padding: 0px;</span><br><span class="line">    display: inline !important;</span><br><span class="line">    vertical-align: text-bottom;</span><br><span class="line">    border: none;</span><br><span class="line">    cursor: text;</span><br><span class="line">    box-shadow: none;</span><br><span class="line">}</span><br><span class="line">// 文章超链接样式（为emoji特设）</span><br><span class="line">.post-body a {</span><br><span class="line">    border-bottom: none;</span><br><span class="line">    text-decoration: underline;</span><br><span class="line">}</span><br><span class="line">.post-body a:hover {</span><br><span class="line">    border-bottom: none;</span><br><span class="line">    text-decoration: underline;</span><br><span class="line">}</span><br><span class="line">// 标签云页面超链接样式（为emoji特设）</span><br><span class="line">.tag-cloud a {</span><br><span class="line">    border-bottom: 1px solid rgb(80, 115, 184);</span><br><span class="line">    text-decoration: none;</span><br><span class="line">}</span><br><span class="line">.tag-cloud a:hover {</span><br><span class="line">    border-bottom: 1px solid rgb(161, 102, 171);</span><br><span class="line">    text-decoration: none;</span><br><span class="line">}</span><br><span class="line">// 文章元数据中categories的样式（为emoji特设）</span><br><span class="line">a.categories {</span><br><span class="line">    border-bottom: none;</span><br><span class="line">    text-decoration: underline;</span><br><span class="line">}</span><br><span class="line">a.categories:hover { </span><br><span class="line">    border-bottom: none;</span><br><span class="line">    text-decoration: underline;</span><br><span class="line">}</span><br><span class="line">// tabs标签（为emoji特设）</span><br><span class="line">.post-body .tabs ul.nav-tabs li.tab a {</span><br><span class="line">    text-decoration: none;</span><br><span class="line">}</span><br><span class="line">// 图片下方标题设置（为emoji特设）</span><br><span class="line">a.fancybox{</span><br><span class="line">    text-decoration: none !important;</span><br><span class="line">}</span><br><span class="line">// 按钮样式（为emoji特设）</span><br><span class="line">.btn {</span><br><span class="line">    text-decoration: none !important;</span><br><span class="line">    border: 2px solid #222 !important;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>然后直接去 <a href="https://www.webpagefx.com/tools/emoji-cheat-sheet/" target="_blank" rel="noopener">Emoji Cheat Sheet</a> 点一下自己想要的表情复制，再粘贴到自己的文章中即可<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f61d.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f61d.png?v8">😝</span><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f60e.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f60e.png?v8">😎</span><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f43e.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f43e.png?v8">🐾</span></p>
<h3 id="背景图片"><a href="#背景图片" class="headerlink" title="背景图片"></a>背景图片</h3><p>我们需要用到<a href="https://github.com/jquery-backstretch/jquery-backstretch" target="_blank" rel="noopener"><code>jquery-backstretch</code></a>，然后修改如下文件：</p>
<figure class="highlight diff"><figcaption><span>文件位置：/themes/next/layout/_layout.swig</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="addition">+  &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-backstretch/2.0.4/jquery.backstretch.min.js"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="addition">+  &lt;script&gt;</span></span><br><span class="line"><span class="addition">+  $("body").backstretch("https://背景图.jpg");</span></span><br><span class="line"><span class="addition">+  &lt;/script&gt;</span></span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>当然还有另外的方法：</p>
<figure class="highlight styl"><figcaption><span>文件位置：/theme/next/source/css/_custom/custom.styl</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 站点背景</span></span><br><span class="line">@media screen and (<span class="attribute">min-width</span>:<span class="number">1200px</span>) {</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">body</span> {</span><br><span class="line">        <span class="attribute">background-image</span>:url(/images/图片);</span><br><span class="line">        <span class="attribute">background-attachment</span>:fixed;</span><br><span class="line">        <span class="attribute">background-position</span>:<span class="number">50%</span> <span class="number">50%</span>; </span><br><span class="line">        <span class="attribute">opacity</span>: <span class="number">0.97</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="selector-id">#footer</span> <span class="selector-tag">a</span> {</span><br><span class="line">        <span class="attribute">color</span>:<span class="number">#eee</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="文章注脚"><a href="#文章注脚" class="headerlink" title="文章注脚"></a>文章注脚</h3><p>安装<code>hexo-footnotes</code><sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup></p>
<figure class="highlight bash"><figcaption><span>执行位置：~/blog</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">npm install hexo-footnotes --save</span><br></pre></td></tr></tbody></table></figure>
<p>使用的方法：</p>
<figure class="highlight markdown"><table><tbody><tr><td class="code"><pre><span class="line">basic footnote<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></span><br><span class="line">here is an inline footnote[<span class="string">^2</span>](<span class="link">inline footnote</span>)</span><br><span class="line">and another one<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup></span><br><span class="line">and another one<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup></span><br><span class="line"></span><br><span class="line">[<span class="symbol">^1</span>]: <span class="link">basic footnote content</span></span><br><span class="line">[<span class="symbol">^3</span>]: <span class="link">paragraph</span></span><br><span class="line">footnote</span><br><span class="line">content</span><br><span class="line">[<span class="string">^4</span>]: footnote content with some [<span class="string">markdown</span>](<span class="link">https://en.wikipedia.org/wiki/Markdown</span>)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>用法：</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line">{% cq %}</span><br><span class="line">人生乃是一面镜子，</span><br><span class="line">从镜子里认识自己，</span><br><span class="line">我要称之为头等大事，</span><br><span class="line">也只是我们追求的目的！</span><br><span class="line">{% endcq %}</span><br></pre></td></tr></tbody></table></figure>
<p>效果：</p>
<blockquote class="blockquote-center"><p>人生乃是一面镜子，<br>从镜子里认识自己，<br>我要称之为头等大事，<br>也只是我们追求的目的！</p>
</blockquote>
<h3 id="note-标签"><a href="#note-标签" class="headerlink" title="note 标签"></a>note 标签</h3><p>现在主题中启动note标签</p>
<figure class="highlight yml"><figcaption><span>文件位置：~/blog/themes/next/_config.yml</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># Note tag (bs-callout).</span></span><br><span class="line"><span class="attr">note:</span></span><br><span class="line">  <span class="comment"># 风格</span></span><br><span class="line"><span class="attr">  style:</span> <span class="string">flat</span></span><br><span class="line">  <span class="comment"># 要不要图标</span></span><br><span class="line"><span class="attr">  icons:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 圆角矩形</span></span><br><span class="line"><span class="attr">  border_radius:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">  light_bg_offset:</span></span><br></pre></td></tr></tbody></table></figure>
<div class="note default"><p>default</p></div>

<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"note default"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>default<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<p>其他还有<code>primary</code>,<code>success</code>,<code>info</code>,<code>warning</code>,<code>danger</code>，若不想要带有图标可以用<code>no-icon</code></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>​        </p>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;"><a href="https://reuixiy.github.io/technology/computer/computer-aided-art/2017/06/09/hexo-next-optimization.html" target="_blank" rel="noopener">reuixiy----打造个性超赞博客Hexo+NexT+GitHubPages的超深度优化</a></span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;"><a href="https://github.com/LouisBarranqueiro/hexo-footnotes" target="_blank" rel="noopener">hexo-footnotes</a></span><a href="#fnref:2" rev="footnote"> ↩</a></li></ol></div></div><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>NexT&amp;第三方服务</title>
    <url>/posts/Next&amp;ThirdPartyServices.html</url>
    <content><![CDATA[<h1 id="文章阅读数量记录"><a href="#文章阅读数量记录" class="headerlink" title="文章阅读数量记录"></a>文章阅读数量记录</h1><p>关于文章阅读数量，可以使用<a href="https://leancloud.cn/" target="_blank" rel="noopener">LeanCloud</a>，还有<a href="https://console.firebase.google.com/u/0/" target="_blank" rel="noopener">Google</a>的，或者是<a href="http://ibruce.info/2015/04/04/busuanzi/" target="_blank" rel="noopener">不蒜子统计</a></p>
<p>这里选用的<strong>LeanCloud</strong>，可以看doublemine这篇<a href="https://notes.doublemine.me/2015-10-21-%E4%B8%BANexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD.html" target="_blank" rel="noopener">文章</a></p>
<p>时间：2020年4月5日</p>
<p>如果LeanCloud的服务长时间不用，会被停掉并且归档，所以还是需要时不时上去看看~</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title>你好,Hexo（01）</title>
    <url>/posts/Hello-Hexo.html</url>
    <content><![CDATA[<p>Hi,米娜桑。这里是ZRoger的博客。由<code>GitHub Page</code>和<code>Hexo</code>构成。<br>所以在这篇文章中，我记录了关于一些<code>Hexo</code>的东西。</p>
<h2 id="关于Hexo"><a href="#关于Hexo" class="headerlink" title="关于Hexo"></a>关于Hexo</h2><p><em>什么是Hexo</em>：</p>
<p>让我们看下<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">官方</a>的回答：<code>Hexo</code>是一个快速，简洁且高效的博客框架。<code>Hexo</code>使用<code>Markdown</code>(或者其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态页面。</p>
<p>我觉得它还是比较受欢迎，当你想记录生活中的事情，无论是琐碎的日志，技术分享，或者其他。都可以使用<code>Hexo</code>创建你的静态博客。但是在文章管理方面并不是很好，但我觉得还是可以一试的。</p>
<a id="more"></a>
<h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><blockquote>
<p><em>注意</em><br>目前只记录了在<code>window</code>系统下的过程。其他系统暂时没有办法涉及，以后有机会再补上。</p>
</blockquote>
<ol>
<li>首先需要安装好<code>Node.js</code>和<code>Git</code>，<code>Node.js</code>用于安装<code>Hexo</code>，而<code>Git</code>则用于连接我们的远程仓库，别忘了创建自己的<code>GitHub</code>账号。下面是检查系统中<code>Node.js</code>版本，使用<code>Git</code>工具打开。</li>
</ol>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ node -v</span><br></pre></td></tr></tbody></table></figure>
<ol>
<li>使用<code>git bash</code>全局安装<code>hexo-cli</code>，为创建博客做准备。</li>
</ol>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></tbody></table></figure>
<ol>
<li><p>在<code>GitHub</code>上创建对应的用户名仓库，格式：<code>github用户名.github.io</code></p>
</li>
<li><p>在本地创建文件夹<code>blog</code>,打开该文件夹后，输入<code>hexo init</code>进行初始化。</p>
</li>
</ol>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> blog</span><br><span class="line">$ hexo init</span><br></pre></td></tr></tbody></table></figure>
<ol>
<li>安装所需依赖</li>
</ol>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ npm install</span><br></pre></td></tr></tbody></table></figure>
<ol>
<li>将<code>Hexo</code>与<code>GitHub Page</code>关联。</li>
</ol>
<p>先检查<code>Git</code>中是否有设置<code>user name</code>和<code>email</code>。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ vi ~/.gitconfig</span><br></pre></td></tr></tbody></table></figure>
<p>或者</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git config user.name</span><br><span class="line">$ git config user.email</span><br></pre></td></tr></tbody></table></figure>
<p>如果没有信息，输入命令进行设置</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">"你的名字"</span></span><br><span class="line">$ git config --global user.eamil <span class="string">"你的邮箱"</span></span><br></pre></td></tr></tbody></table></figure>
<p>之后，再检查本地中是否存在<code>/.ssh</code>：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/.ssh</span><br><span class="line">$ ls</span><br></pre></td></tr></tbody></table></figure>
<p>接着生成密钥，用于关联到你的<code>GitHub</code>账号中：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">"你的邮箱"</span></span><br></pre></td></tr></tbody></table></figure>
<ol>
<li>在连续回车3次，就生成密钥和公钥。将<code>id_rsa.pub</code>填到<code>GitHub</code>账户上。然后使用添加密钥到<code>ssh-agent</code>:</li>
</ol>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">eval</span> <span class="string">"<span class="variable">$(ssh-agent -s)</span>"</span></span><br></pre></td></tr></tbody></table></figure>
<p>添加生成的<code>ssh key</code>到<code>ssh-agent</code>中</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ ssh-add ~/.ssh/id_rsa</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>关<code>ssh-agent</code><br>是一个密钥管理器，将私钥交给<code>ssh-agent</code>保管后，其他程序需要身份验证的时候，就可以将验证的申请交给<code>ssh-agent</code>来完成。这里是解决每次<code>Hexo</code>部署新文章的时候，不需要重复输入登录名和密码。配置<code>ssh-key</code>让<code>Git</code>到<code>GitHub</code>切换自如，不用再验证身份。</p>
</blockquote>
<ol>
<li>测试一下</li>
</ol>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br></pre></td></tr></tbody></table></figure>
<ol>
<li>修改<code>blog</code>文件夹下面的<code>_config.yml</code>文件，添加远程仓库</li>
</ol>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git </span><br><span class="line">  repository: 你的仓库的ssh</span><br><span class="line">  branch: master</span><br></pre></td></tr></tbody></table></figure>
<h3 id="生成和部署文章"><a href="#生成和部署文章" class="headerlink" title="生成和部署文章"></a>生成和部署文章</h3><p><em>新建一篇文章</em></p>
<ol>
<li>在<code>git bash</code>中输入：</li>
</ol>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo new post 文章名字</span><br></pre></td></tr></tbody></table></figure>
<ol>
<li>在生成以及部署文章之前，需要再安装一个扩展，不然很有可能你的文章会部署失败:</li>
</ol>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></tbody></table></figure>
<ol>
<li>生成静态文件，然后在本地上先看下效果</li>
</ol>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo g</span><br></pre></td></tr></tbody></table></figure>
<p>启动Hexo服务器，默认的端口<code>4000</code>：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo s</span><br></pre></td></tr></tbody></table></figure>
<ol>
<li>部署文章到服务器上，查看的地址格式：<code>github用户名.github.io</code></li>
</ol>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo d</span><br></pre></td></tr></tbody></table></figure>
<p>当然也可以简单点，直接生成并更新文章到<code>GitHub</code>上：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo d -g</span><br></pre></td></tr></tbody></table></figure>
<h2 id="小结一下"><a href="#小结一下" class="headerlink" title="小结一下"></a>小结一下</h2><p>大概的流程是这样的，<code>Hexo</code>将编辑好的<code>md</code>文件生成静态<code>Web</code>文件，当然还有其他的文件，再上传到<code>GitHub</code>上，添加<code>ssh-agent</code>，方便每次部署你的文章。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript浮点计算</title>
    <url>/posts/JavaScript&amp;Calculation.html</url>
    <content><![CDATA[<h2 id="0-30000000000000004"><a href="#0-30000000000000004" class="headerlink" title="0.30000000000000004"></a>0.30000000000000004</h2><p>在前端进行业务的计算时，出现了一点错误：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var a = 0.1 ;</span><br><span class="line">var b = 0.2 ;</span><br><span class="line">console.log(a+b);</span><br><span class="line"></span><br><span class="line">// 结果</span><br><span class="line">0.30000000000000004</span><br></pre></td></tr></tbody></table></figure>
<p>很奇怪，为什么不直接等于<code>0.3</code></p>
<h3 id="JavaScript中的数字"><a href="#JavaScript中的数字" class="headerlink" title="JavaScript中的数字"></a>JavaScript中的数字</h3><p>数值始终是64位的双精度浮点数，0到51存储数字（片段），52 到 62 存储指数，63 位存储符号。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">值(aka Fraction/Mantissa)</th>
<th style="text-align:left">指数</th>
<th style="text-align:left">符号</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">52 bits(0 - 51)</td>
<td style="text-align:left">11 bits (52 - 62)</td>
<td style="text-align:left">1 bit (63)</td>
</tr>
</tbody>
</table>
</div>
<p> 整数会被精确到15位、小数最大数是17位。</p>
<h4 id="对于小数的二进制"><a href="#对于小数的二进制" class="headerlink" title="对于小数的二进制"></a>对于小数的二进制</h4><p>系统是将10进制转为二进制再进行计算，<code>0.1</code>的二进制是<code>0001100110...</code>，后面就一直重复<code>0011</code>，<code>0.2</code>的二进制是<code>0011..</code>，也是重复<code>0011</code>。两个二进制再相加，再转为十进制就是<code>0.30000000000000004</code>。</p>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>1、 先乘后除，缺点是 相乘的结果已经超过了 <strong>MAX_SAFE_INTEGER</strong> 会出现错误</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var x = (0.2 * 10 + 0.1 * 10) / 10;</span><br></pre></td></tr></tbody></table></figure>
<p>2、指定精度的四舍五入，小数太多，也不是很理想</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var a = 0.1 ;</span><br><span class="line">var b = 0.2 ;</span><br><span class="line">var c = a+b ;</span><br><span class="line">console.log(parseFloat(c.toFixed(12)));</span><br></pre></td></tr></tbody></table></figure>
<p>3、将浮点数转字符串，再模拟实际计算</p>
<p> <a href="https://github.com/MikeMcl/bignumber.js" target="_blank" rel="noopener">bignumber.js</a>，<a href="https://github.com/MikeMcl/decimal.js" target="_blank" rel="noopener">decimal.js</a>，以及<a href="https://github.com/MikeMcl/big.js" target="_blank" rel="noopener">big.js</a>等</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>axios 小结</title>
    <url>/posts/axios-01.html</url>
    <content><![CDATA[<h1 id="Axios-使用小结"><a href="#Axios-使用小结" class="headerlink" title="Axios 使用小结"></a>Axios 使用小结</h1><p>工作的项目是前后端分离的，前端项目采用 <code>Vue</code> 相关的技术栈进行搭建，与此同时，前端请求的方式也发生了改变，由原来 <code>Jquery</code> 中 <code>ajax</code> 变为 <code>axios</code> ；</p>
<p>在使用的过程中当然存在一些疑问，在这里作下小小的汇总；</p>
<a id="more"></a>
<h2 id="axios-是什么"><a href="#axios-是什么" class="headerlink" title="axios 是什么"></a>axios 是什么</h2><p>GitHub 地址：<a href="https://github.com/axios/axios" target="_blank" rel="noopener">https://github.com/axios/axios</a>，aixos 是一个基于<code>Promise</code>的<code>Http</code>库，主要使用在浏览器和以<code>node.js</code>作为后端的应用中。安装和使用官网里已经有了，可以看下中文网的<a href="http://www.axios-js.com/zh-cn/docs/index.html" target="_blank" rel="noopener">文档</a>。</p>
<h3 id="简单对比"><a href="#简单对比" class="headerlink" title="简单对比"></a>简单对比</h3><p>两种库的请求：</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Jquery ajax post 侵吞跪求</span></span><br><span class="line">$.ajax({</span><br><span class="line">	url: <span class="string">'http://openapi.xx.com/xx/'</span>,</span><br><span class="line">	type: <span class="string">'POST'</span>,</span><br><span class="line">	data:{</span><br><span class="line">    	id:<span class="string">'123'</span></span><br><span class="line">	},</span><br><span class="line">	successs:<span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>{</span><br><span class="line">		<span class="built_in">console</span>.log(result)</span><br><span class="line">	}</span><br><span class="line">}})</span><br><span class="line"></span><br><span class="line"><span class="comment">// axios</span></span><br><span class="line">axios.post(</span><br><span class="line">    <span class="string">'http://openapi.xx.com/xx/'</span>,</span><br><span class="line">    {<span class="attr">id</span>:<span class="string">'123'</span>}</span><br><span class="line">).then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>{</span><br><span class="line">    <span class="built_in">console</span>.log(result)</span><br><span class="line">}).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>{</span><br><span class="line">    <span class="built_in">console</span>.log(error)</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>
<h3 id="执行多个并发请求"><a href="#执行多个并发请求" class="headerlink" title="执行多个并发请求"></a>执行多个并发请求</h3><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 获取用户公开信息</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchUserInfo</span>(<span class="params">userId</span>) </span>{</span><br><span class="line">  <span class="keyword">return</span> axios.get(<span class="string">"/user/"</span> + userId);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取用户设置偏好</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchUserPreference</span>(<span class="params">userId</span>) </span>{</span><br><span class="line">  <span class="keyword">return</span> axios.get(<span class="string">"/user/"</span> + userId + <span class="string">"/preference"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> userId = <span class="string">"123"</span>;</span><br><span class="line">axios.all([fetchUserInfo(userId), fetchUserPreference(userId)]).then(</span><br><span class="line">  axios.spread(<span class="function"><span class="keyword">function</span> (<span class="params">acct, perms</span>) </span>{</span><br><span class="line">    <span class="comment">// 两个请求都执行完成</span></span><br><span class="line">  })</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure>
<h2 id="项目中的封装"><a href="#项目中的封装" class="headerlink" title="项目中的封装"></a>项目中的封装</h2><p><code>axios</code>提供<code>api</code>来传递配置创建请求，所以可以进行一个简易的封装，方便前端统一管理接口。避免在<code>main.js</code>或者各个<code>vue</code>文件中重复引入<code>axios</code>；或者写相同的接口，如：<code>axios.get('/user?ID=12345')</code>。</p>
<h3 id="简单封装-request-js"><a href="#简单封装-request-js" class="headerlink" title="简单封装 request.js"></a>简单封装 request.js</h3><p>使用自定义配置创建一个<code>axios</code>实例，其他<code>api.js</code>使用这个实例进行创建</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"><span class="keyword">import</span> qs <span class="keyword">from</span> <span class="string">'querystring'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// axios instance</span></span><br><span class="line"><span class="keyword">const</span> service = axios.create({</span><br><span class="line">  baseURL: 后端接口地址,</span><br><span class="line">  timeout: <span class="number">10000</span></span><br><span class="line">})</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求拦截</span></span><br><span class="line">service.interceptors.request.use(.....)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应拦截</span></span><br><span class="line">service.interceptors.response.use(.....)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> service</span><br></pre></td></tr></tbody></table></figure>
<p>请求拦截，在 axios 中，post 请求中的数据会传递 json 形式的数据回到后端，即<code>Content-Type</code>为<code>appliaction/json</code>；后端的接口需要加上注解<code>@RequestBody</code>来接收<code>json</code>参数，为了兼容一下老的接口需要作一定的处理</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// request interceptor</span></span><br><span class="line">service.interceptors.request.use(</span><br><span class="line">  (config) =&gt; {</span><br><span class="line">    <span class="keyword">if</span> (config.data <span class="keyword">instanceof</span> FormData) {</span><br><span class="line">      <span class="comment">// 文件</span></span><br><span class="line">      config.headers[<span class="string">"Content-Type"</span>] = <span class="string">"multipart/form-data"</span>;</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (config.dataType === <span class="string">"json"</span>) {</span><br><span class="line">      <span class="comment">// 当要传递 json 形式的数据时，改变 content-type</span></span><br><span class="line">      config.headers[<span class="string">"Content-Type"</span>] = <span class="string">"application/json"</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="comment">// get/post</span></span><br><span class="line">      config.headers[<span class="string">"Content-Type"</span>] = <span class="string">"application/x-www-form-urlencoded"</span>;</span><br><span class="line">      config.data = qs.stringify(config.data);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// config headers token</span></span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">  },</span><br><span class="line">  (error) =&gt; {</span><br><span class="line">    <span class="comment">// do something with request error</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">  }</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure>
<p>返回信息拦截</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// response interceptor</span></span><br><span class="line">service.interceptors.response.use(</span><br><span class="line">  (response) =&gt; {</span><br><span class="line">    <span class="keyword">return</span> response.data;</span><br><span class="line">  },</span><br><span class="line">  (error) =&gt; {</span><br><span class="line">    <span class="keyword">if</span> (error.response) {</span><br><span class="line">      <span class="keyword">if</span> (error.response.status === <span class="number">40001</span>) {</span><br><span class="line">        <span class="comment">// 返回登录页面</span></span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">  }</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure>
<h3 id="使用-request-js"><a href="#使用-request-js" class="headerlink" title="使用 request.js"></a>使用 request.js</h3><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> request <span class="keyword">from</span> <span class="string">"@/http/request"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">fetchDemoPage</span>(<span class="params">params</span>) </span>{</span><br><span class="line">  <span class="keyword">return</span> request({</span><br><span class="line">    url: <span class="string">"/demo/page"</span>,</span><br><span class="line">    method: <span class="string">"get"</span>,</span><br><span class="line">    params,</span><br><span class="line">  });</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>为了方便维护前端 api 函数，在 vue 项目生成的 src 中创建<code>api</code>文件夹。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">+---api</span><br><span class="line">|   +---public</span><br><span class="line">|   |   +---sign</span><br></pre></td></tr></tbody></table></figure>
<h3 id="封装-BaseApi"><a href="#封装-BaseApi" class="headerlink" title="封装 BaseApi"></a>封装 BaseApi</h3><p>随着写模块越来越多，自热而然会产生一些重复的代码，比如：</p>
<p>a-api.js</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">import request from '@/http/request'</span><br><span class="line"></span><br><span class="line">export function fetchDemoAPage(params) {</span><br><span class="line">  return request({</span><br><span class="line">    url: '/a/page',</span><br><span class="line">    method: 'get',</span><br><span class="line">    params</span><br><span class="line">  })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>b-api.js</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">import request from '@/http/request'</span><br><span class="line"></span><br><span class="line">export function fetchDemoBPage(params) {</span><br><span class="line">  return request({</span><br><span class="line">    url: '/b/page',</span><br><span class="line">    method: 'get',</span><br><span class="line">    params</span><br><span class="line">  })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>接口形式差不多，感觉可以抽离一个公共的 js 进行调整，当然这个封装的前提是<strong>前后端都约定后一些通用的接口形式</strong></p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseApi</span> </span>{</span><br><span class="line">    <span class="keyword">constructor</span>(microservice, controller){</span><br><span class="line">        <span class="keyword">this</span>.microservice = microservice</span><br><span class="line">        <span class="keyword">this</span>.controller = controller</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分页</span></span><br><span class="line">        <span class="keyword">this</span>.page = BaseApi.get(<span class="string">'page'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取vo实体</span></span><br><span class="line">        <span class="keyword">this</span>.fetchData = BaseApi.get(<span class="string">'find'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除实体</span></span><br><span class="line">        <span class="keyword">this</span>.delData = BaseApi.post(<span class="string">'delete'</span>)</span><br><span class="line"></span><br><span class="line">        .... 省略</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> get(methodPath){</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">params</span>)</span>{</span><br><span class="line">            <span class="keyword">return</span> request({</span><br><span class="line">                url: <span class="keyword">this</span>.microservice + <span class="string">'/'</span> + <span class="keyword">this</span>.controller + <span class="string">'/'</span> + methodPath,</span><br><span class="line">                method:<span class="string">'get'</span>,</span><br><span class="line">                params</span><br><span class="line">            })</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> post(methodPath){</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>{</span><br><span class="line">            <span class="keyword">return</span> request({</span><br><span class="line">                url: <span class="keyword">this</span>.microservice + <span class="string">'/'</span> + <span class="keyword">this</span>.controller + <span class="string">'/'</span> + methodPath,</span><br><span class="line">                method: <span class="string">'post'</span>,</span><br><span class="line">                data</span><br><span class="line">            })</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> postJson(..){...}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="使用-BaseApi"><a href="#使用-BaseApi" class="headerlink" title="使用 BaseApi"></a>使用 BaseApi</h3><p>user-sign.js 用户注册相关 api</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> BaseApi <span class="keyword">from</span> <span class="string">"@/api/base"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> api = <span class="keyword">new</span> BaseApi(<span class="string">"user"</span>, <span class="string">"sign"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义api</span></span><br><span class="line">api.test = EntBaseApi.get(<span class="string">"test/getReleaseList"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> api;</span><br></pre></td></tr></tbody></table></figure>
<h2 id="其他："><a href="#其他：" class="headerlink" title="其他："></a>其他：</h2><p>其他一些比较重要的，就列在这里，来源官网</p>
<h3 id="请求方法的别名"><a href="#请求方法的别名" class="headerlink" title="请求方法的别名"></a>请求方法的别名</h3><p>为方便起见，为所有支持的请求方法提供了别名</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line">axios.request(config)</span><br><span class="line"></span><br><span class="line">axios.get(url[, config])</span><br><span class="line"></span><br><span class="line">axios.delete(url[, config])</span><br><span class="line"></span><br><span class="line">axios.head(url[, config])</span><br><span class="line"></span><br><span class="line">axios.options(url[, config])</span><br><span class="line"></span><br><span class="line">axios.post(url[, data[, config]])</span><br><span class="line"></span><br><span class="line">axios.put(url[, data[, config]])</span><br><span class="line"></span><br><span class="line">axios.patch(url[, data[, config]])</span><br></pre></td></tr></tbody></table></figure>
<p><strong>注意</strong></p>
<p>在使用别名方法时， <code>url</code>、<code>method</code>、<code>data</code> 这些属性都不必在配置中指定。</p>
<h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>处理并发请求的助手函数</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line">axios.all(iterable);</span><br><span class="line"></span><br><span class="line">axios.spread(callback);</span><br></pre></td></tr></tbody></table></figure>
<h3 id="创建请求时后的配置"><a href="#创建请求时后的配置" class="headerlink" title="创建请求时后的配置"></a>创建请求时后的配置</h3><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line">{</span><br><span class="line">   <span class="comment">// `url` 是用于请求的服务器 URL</span></span><br><span class="line">  url: <span class="string">'/user'</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `method` 是创建请求时使用的方法</span></span><br><span class="line">  method: <span class="string">'get'</span>, <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。</span></span><br><span class="line">  <span class="comment">// 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL</span></span><br><span class="line">  baseURL: <span class="string">'https://some-domain.com/api/'</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `transformRequest` 允许在向服务器发送前，修改请求数据</span></span><br><span class="line">  <span class="comment">// 只能用在 'PUT', 'POST' 和 'PATCH' 这几个请求方法</span></span><br><span class="line">  <span class="comment">// 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream</span></span><br><span class="line">  transformRequest: [<span class="function"><span class="keyword">function</span> (<span class="params">data, headers</span>) </span>{</span><br><span class="line">    <span class="comment">// 对 data 进行任意转换处理</span></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  }],</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `transformResponse` 在传递给 then/catch 前，允许修改响应数据</span></span><br><span class="line">  transformResponse: [<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>{</span><br><span class="line">    <span class="comment">// 对 data 进行任意转换处理</span></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  }],</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `headers` 是即将被发送的自定义请求头</span></span><br><span class="line">  headers: {<span class="string">'X-Requested-With'</span>: <span class="string">'XMLHttpRequest'</span>},</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `params` 是即将与请求一起发送的 URL 参数</span></span><br><span class="line">  <span class="comment">// 必须是一个无格式对象(plain object)或 URLSearchParams 对象</span></span><br><span class="line">  params: {</span><br><span class="line">    ID: <span class="number">12345</span></span><br><span class="line">  },</span><br><span class="line"></span><br><span class="line">   <span class="comment">// `paramsSerializer` 是一个负责 `params` 序列化的函数</span></span><br><span class="line">  <span class="comment">// (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/)</span></span><br><span class="line">  paramsSerializer: <span class="function"><span class="keyword">function</span>(<span class="params">params</span>) </span>{</span><br><span class="line">    <span class="keyword">return</span> Qs.stringify(params, {<span class="attr">arrayFormat</span>: <span class="string">'brackets'</span>})</span><br><span class="line">  },</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `data` 是作为请求主体被发送的数据</span></span><br><span class="line">  <span class="comment">// 只适用于这些请求方法 'PUT', 'POST', 和 'PATCH'</span></span><br><span class="line">  <span class="comment">// 在没有设置 `transformRequest` 时，必须是以下类型之一：</span></span><br><span class="line">  <span class="comment">// - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams</span></span><br><span class="line">  <span class="comment">// - 浏览器专属：FormData, File, Blob</span></span><br><span class="line">  <span class="comment">// - Node 专属： Stream</span></span><br><span class="line">  data: {</span><br><span class="line">    firstName: <span class="string">'Fred'</span></span><br><span class="line">  },</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `timeout` 指定请求超时的毫秒数(0 表示无超时时间)</span></span><br><span class="line">  <span class="comment">// 如果请求话费了超过 `timeout` 的时间，请求将被中断</span></span><br><span class="line">  timeout: <span class="number">1000</span>,</span><br><span class="line"></span><br><span class="line">   <span class="comment">// `withCredentials` 表示跨域请求时是否需要使用凭证</span></span><br><span class="line">  withCredentials: <span class="literal">false</span>, <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `adapter` 允许自定义处理请求，以使测试更轻松</span></span><br><span class="line">  <span class="comment">// 返回一个 promise 并应用一个有效的响应 (查阅 [response docs](#response-api)).</span></span><br><span class="line">  adapter: <span class="function"><span class="keyword">function</span> (<span class="params">config</span>) </span>{</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  },</span><br><span class="line"></span><br><span class="line"> <span class="comment">// `auth` 表示应该使用 HTTP 基础验证，并提供凭据</span></span><br><span class="line">  <span class="comment">// 这将设置一个 `Authorization` 头，覆写掉现有的任意使用 `headers` 设置的自定义 `Authorization`头</span></span><br><span class="line">  auth: {</span><br><span class="line">    username: <span class="string">'janedoe'</span>,</span><br><span class="line">    password: <span class="string">'s00pers3cret'</span></span><br><span class="line">  },</span><br><span class="line"></span><br><span class="line">   <span class="comment">// `responseType` 表示服务器响应的数据类型，可以是 'arraybuffer', 'blob', 'document', 'json', 'text', 'stream'</span></span><br><span class="line">  responseType: <span class="string">'json'</span>, <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `responseEncoding` indicates encoding to use for decoding responses</span></span><br><span class="line">  <span class="comment">// Note: Ignored for `responseType` of 'stream' or client-side requests</span></span><br><span class="line">  responseEncoding: <span class="string">'utf8'</span>, <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// `xsrfCookieName` 是用作 xsrf token 的值的cookie的名称</span></span><br><span class="line">  xsrfCookieName: <span class="string">'XSRF-TOKEN'</span>, <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `xsrfHeaderName` is the name of the http header that carries the xsrf token value</span></span><br><span class="line">  xsrfHeaderName: <span class="string">'X-XSRF-TOKEN'</span>, <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// `onUploadProgress` 允许为上传处理进度事件</span></span><br><span class="line">  onUploadProgress: <span class="function"><span class="keyword">function</span> (<span class="params">progressEvent</span>) </span>{</span><br><span class="line">    <span class="comment">// Do whatever you want with the native progress event</span></span><br><span class="line">  },</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `onDownloadProgress` 允许为下载处理进度事件</span></span><br><span class="line">  onDownloadProgress: <span class="function"><span class="keyword">function</span> (<span class="params">progressEvent</span>) </span>{</span><br><span class="line">    <span class="comment">// 对原生进度事件的处理</span></span><br><span class="line">  },</span><br><span class="line"></span><br><span class="line">   <span class="comment">// `maxContentLength` 定义允许的响应内容的最大尺寸</span></span><br><span class="line">  maxContentLength: <span class="number">2000</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `validateStatus` 定义对于给定的HTTP 响应状态码是 resolve 或 reject  promise 。如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，promise 将被 resolve; 否则，promise 将被 rejecte</span></span><br><span class="line">  validateStatus: <span class="function"><span class="keyword">function</span> (<span class="params">status</span>) </span>{</span><br><span class="line">    <span class="keyword">return</span> status &gt;= <span class="number">200</span> &amp;&amp; status &lt; <span class="number">300</span>; <span class="comment">// default</span></span><br><span class="line">  },</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `maxRedirects` 定义在 node.js 中 follow 的最大重定向数目</span></span><br><span class="line">  <span class="comment">// 如果设置为0，将不会 follow 任何重定向</span></span><br><span class="line">  maxRedirects: <span class="number">5</span>, <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `socketPath` defines a UNIX Socket to be used in node.js.</span></span><br><span class="line">  <span class="comment">// e.g. '/var/run/docker.sock' to send requests to the docker daemon.</span></span><br><span class="line">  <span class="comment">// Only either `socketPath` or `proxy` can be specified.</span></span><br><span class="line">  <span class="comment">// If both are specified, `socketPath` is used.</span></span><br><span class="line">  socketPath: <span class="literal">null</span>, <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `httpAgent` 和 `httpsAgent` 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理。允许像这样配置选项：</span></span><br><span class="line">  <span class="comment">// `keepAlive` 默认没有启用</span></span><br><span class="line">  httpAgent: <span class="keyword">new</span> http.Agent({ <span class="attr">keepAlive</span>: <span class="literal">true</span> }),</span><br><span class="line">  httpsAgent: <span class="keyword">new</span> https.Agent({ <span class="attr">keepAlive</span>: <span class="literal">true</span> }),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 'proxy' 定义代理服务器的主机名称和端口</span></span><br><span class="line">  <span class="comment">// `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据</span></span><br><span class="line">  <span class="comment">// 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。</span></span><br><span class="line">  proxy: {</span><br><span class="line">    host: <span class="string">'127.0.0.1'</span>,</span><br><span class="line">    port: <span class="number">9000</span>,</span><br><span class="line">    auth: {</span><br><span class="line">      username: <span class="string">'mikeymike'</span>,</span><br><span class="line">      password: <span class="string">'rapunz3l'</span></span><br><span class="line">    }</span><br><span class="line">  },</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `cancelToken` 指定用于取消请求的 cancel token</span></span><br><span class="line">  cancelToken: <span class="keyword">new</span> CancelToken(<span class="function"><span class="keyword">function</span> (<span class="params">cancel</span>) </span>{</span><br><span class="line">  })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="响应结构"><a href="#响应结构" class="headerlink" title="响应结构"></a>响应结构</h3><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="comment">// `data` 由服务器提供的响应</span></span><br><span class="line">  data: {},</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `status` 来自服务器响应的 HTTP 状态码</span></span><br><span class="line">  status: <span class="number">200</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `statusText` 来自服务器响应的 HTTP 状态信息</span></span><br><span class="line">  statusText: <span class="string">'OK'</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `headers` 服务器响应的头</span></span><br><span class="line">  headers: {},</span><br><span class="line"></span><br><span class="line">   <span class="comment">// `config` 是为请求提供的配置信息</span></span><br><span class="line">  config: {},</span><br><span class="line"> <span class="comment">// 'request'</span></span><br><span class="line">  <span class="comment">// `request` is the request that generated this response</span></span><br><span class="line">  <span class="comment">// It is the last ClientRequest instance in node.js (in redirects)</span></span><br><span class="line">  <span class="comment">// and an XMLHttpRequest instance the browser</span></span><br><span class="line">  request: {}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="http://www.axios-js.com/zh-cn/docs/index.html" target="_blank" rel="noopener">http://www.axios-js.com/zh-cn/docs/index.html</a></li>
<li><a href="https://github.com/PanJiaChen/vue-element-admin/blob/master/src/utils/request.js" target="_blank" rel="noopener">https://github.com/PanJiaChen/vue-element-admin/blob/master/src/utils/request.js</a></li>
</ol>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>axios</tag>
      </tags>
  </entry>
  <entry>
    <title>Dec. 18 blog (01)</title>
    <url>/posts/Dec-18-blog-01.html</url>
    <content><![CDATA[<h2 id="大雪之后"><a href="#大雪之后" class="headerlink" title="大雪之后"></a>大雪之后</h2><p>记于12月09日，距离新的一年还有22天。</p>
<p><img src="/posts/./Dec-18-blog-01/dec.jpg" alt="开头"></p>
<p>7号是大雪气节，是仲冬的开始。开始冷了起来，时不时会有些小雨飘在街上，让人忍不住拉了拉衣领，把脖子缩进去。终于可以看到呼出的白气。圣诞的气温已经准备好了，我看到有人排出了圣诞树，虽然时间还早的很。</p>
<a id="more"></a>
<h2 id="绘画"><a href="#绘画" class="headerlink" title="绘画"></a><strong>绘画</strong></h2><hr>

<p>点击标题即可跳转相应的站点</p>
<p>1、<strong><a href="http://www.nicholashelyhutchinson.com/" target="_blank" rel="noopener" class="imgPost-title-url">nicholashelyhutchinson</a></strong></p>
<p><img src="/posts/./Dec-18-blog-01/nicholashelyhutchinson/The-Old-Fishing-Boat-Walberswick.jpg" alt="nicholashelyhutchinson"></p>
<p><img src="/posts/./Dec-18-blog-01/nicholashelyhutchinson/The-Cold-Road-to-Dorchester-1000x753_c.jpg" alt="nicholashelyhutchinson">    </p>
<p><img src="/posts/./Dec-18-blog-01/nicholashelyhutchinson/slider_img-1000x669_c.jpg" alt="nicholashelyhutchinson"></p>
<p>​    Nicholas Hely Hutchinson出身于1955年，1984年首次举行个人绘画展览，一直在英国伦敦，都柏林还有香港展出。他和妻子住在英国的多塞特郡，从周围的海岸和乡村获得灵感，季节和乡村的变化是他灵感来源 。云层下的乡间和人，寒冬里的鸟儿，阳光照射笔直的路，这就他想要的画面。</p>
<p>2、<strong><a href="https://danaradic.com" target="_blank" rel="noopener" class="imgPost-title-url">danaradic</a></strong></p>
<p><img src="/posts/./Dec-18-blog-01/danaradic/play-doh-astronauta-ddb-chile-april-20151.jpg" alt="danaradic"></p>
<p><img src="/posts/./Dec-18-blog-01/danaradic/the_shining_scene_repetition_-_video_on_demand2-2_aotw.jpg" alt="danaradic"></p>
<p>​    这其实是一个创意广告的网站，可以看到许多非常有趣的东西，不得不说脑洞是真的大，里面还有大鲨鱼和闪灵的创意图片，你可以前往看看。</p>
<p>3、<strong><a href="https://www.pandagun.com" target="_blank" rel="noopener" class="imgPost-title-url">pandagun</a></strong></p>
<p><img src="/posts/./Dec-18-blog-01/pandagun/kenard_pak_chestnut_breasted_manniken_72dpi_v02_744.jpg" alt="pandagun"></p>
<p>​    作者叫Catbird Agency，住在旧金山，喜欢画画，讲述安静，不寻常的故事。感觉他的画很有趣（我保证）。</p>
<p>​    </p>
<p><strong>小结：</strong></p>
<p>​        本周就这样吧，在想有没有什么好玩的，其实是可以po出来的。让我再想想吧。</p>
<p>​        以上。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>绘画</tag>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title>从排序数组中删除重复项</title>
    <url>/posts/Remove-Duplicates-from-Sorted-Array.html</url>
    <content><![CDATA[<h2 id="题目地址"><a href="#题目地址" class="headerlink" title="题目地址"></a>题目地址</h2><p>题目地址：<a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">https://leetcode.com/problems/remove-duplicates-from-sorted-array/</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul>
<li>数组下标</li>
<li>快慢指针</li>
</ul>
<p>使用快慢指针来记录遍历的坐标。</p>
<ul>
<li>开始时这两个指针都指向第一个数字</li>
<li>如果两个指针指的数字相同，则快指针向前走一步</li>
<li>如果不同，则两个指针都向前走一步（之后将慢指针所在的节点值换成快指针所指位置）</li>
<li>当快指针走完整个数组后，慢指针当前的坐标加1就是数组中不同数字的个数</li>
</ul>
<a id="more"></a>
<h2 id="草稿模拟"><a href="#草稿模拟" class="headerlink" title="草稿模拟"></a>草稿模拟</h2><div class="table-container">
<table>
<thead>
<tr>
<th>数组下标</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody>
<tr>
<td>数组</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>2</td>
<td>3</td>
<td>3</td>
<td>4</td>
</tr>
<tr>
<td>快指针</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>慢指针</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p style="text-align: center;">初始时</p>



<div class="table-container">
<table>
<thead>
<tr>
<th>数组下标</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody>
<tr>
<td>数组</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>2</td>
<td>3</td>
<td>3</td>
<td>4</td>
</tr>
<tr>
<td>快指针</td>
<td></td>
<td>1</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>慢指针</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p style="text-align: center;">两个指针指的数字相同，则快指针向前走一步</p>


<div class="table-container">
<table>
<thead>
<tr>
<th>数组下标</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody>
<tr>
<td>数组</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>2</td>
<td>3</td>
<td>3</td>
<td>4</td>
</tr>
<tr>
<td>快指针</td>
<td></td>
<td></td>
<td>2</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>慢指针</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p style="text-align: center;">当2个指针对应的值不相同时</p>


<div class="table-container">
<table>
<thead>
<tr>
<th>数组下标</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody>
<tr>
<td>数组</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>2</td>
<td>3</td>
<td>3</td>
<td>4</td>
</tr>
<tr>
<td>快指针</td>
<td></td>
<td></td>
<td>2</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>慢指针</td>
<td></td>
<td>1</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p style="text-align: center;">慢指针前进一步，将当前的值换成快指针所在值</p>


<p>接下来的步骤就是如上这般，最终的结果：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>数组下标</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody>
<tr>
<td>数组</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>2</td>
<td>2</td>
<td>3</td>
<td>3</td>
<td>4</td>
</tr>
<tr>
<td>快指针</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>9</td>
</tr>
<tr>
<td>慢指针</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>4</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p style="text-align: center;">最终结果</p>


<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> length = nums.length ;</span><br><span class="line">        <span class="keyword">int</span> lowPoint = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> fastPoint = <span class="number">0</span> ; fastPoint &lt; length ; fastPoint++){</span><br><span class="line">            <span class="keyword">if</span>(nums[fastPoint] != nums[lowPoint] ){</span><br><span class="line">                lowPoint ++ ;</span><br><span class="line">                nums[lowPoint] = nums[fastPoint];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> lowPoint + <span class="number">1</span> ; </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>Array</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Dec. 18 blog (02)</title>
    <url>/posts/Dec-18-blog-02.html</url>
    <content><![CDATA[<h2 id="Dec-blog-02"><a href="#Dec-blog-02" class="headerlink" title="Dec. blog(02)"></a>Dec. blog(02)</h2><p>​    之前看过《小王子》的电影，最近和朋友出去玩的时候，路过一个书店，偶然间想买本原著回来看看。故事很短，结局也让人不禁遐想，最后小王子是否回到那颗属于他的星球，他那爱慕虚荣的玫瑰还会驯养他吗？或者正在除掉刚刚发现的面包树苗，累了就在死火山上休息下，或者搬凳子去看看日落也好。</p>
<p><img src="/posts/./Dec-18-blog-02/pre.jpg" alt="前言"></p>
<a id="more"></a>
<h2 id="博客画师"><a href="#博客画师" class="headerlink" title="博客画师"></a><strong>博客画师</strong></h2><hr>

<p>这里是平时收集到的一些画，主要都是从意匠微博那边看到，然后再到对应的画师博客中浏览。希望能像收集瓶盖一样，越来越多，越来越有趣。（PS：意匠在微博上面，一天就更新了7到8条有关于画师或者设计有关的微博，感兴趣的可以到微博上面关注他们，搜索 <strong><a href="https://weibo.com/mdabao" target="_blank" rel="noopener">意匠id</a></strong> <span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f448.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f448.png?v8">👈</span> 就可以了，我也只是选择个人喜好的进行浏览，一个星期积累就很多了。）</p>
<p>1、<strong><a href="https://mrmisang.com/" target="_blank" class="imgPost-title-url">mr misang</a></strong><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f448.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f448.png?v8">👈</span></p>
<p><img src="/posts/./Dec-18-blog-02/mrmisang/1.jpg" alt="mr misang-1"></p>
<p><img src="/posts/./Dec-18-blog-02/mrmisang/2.jpg" alt="mr misang-2"></p>
<p><img src="/posts/./Dec-18-blog-02/mrmisang/3.gif" alt="mr misang-3"></p>
<p><img src="/posts/./Dec-18-blog-02/mrmisang/4.jpg" alt="mr misang-4"></p>
<p><img src="/posts/./Dec-18-blog-02/mrmisang/5.jpg" alt="mr misang-5"></p>
<p><img src="/posts/./Dec-18-blog-02/mrmisang/6.jpg" alt="mr misang-6"></p>
<p>这是一组很有趣的“连环画”，在我看来是，大人每天在为了生计，为了金钱而忙碌，叹息，渐渐他们就变得差不多。每个人都是肥头大耳的，内心充满烦躁。终于有一天，“我”受不了，挣脱了出来。以上是我自己的胡思乱想，每一幅画都有丰富的元素，每个人的喜怒哀热等等。感觉里面的图案或许能成为潮流</p>
<p>2、<strong><a href="https://yoirene.com/" target="_blank" class="imgPost-title-url">yo irene</a></strong><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f448.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f448.png?v8">👈</span></p>
<p><img src="/posts/./Dec-18-blog-02/yoirene/2.jpg" alt="yo irene-2"></p>
<p><img src="/posts/./Dec-18-blog-02/yoirene/3.jpg" alt="yo irene-3"></p>
<p>意大利插画师 Irene Rinaldi，其他信息我在网站没有看到。像小时候瓷碗上面的图案，看起来像是涂鸦。</p>
<p>3、<strong><a href="https://sandralstrohscheinfineart.com" target="_blank" rel="noopener" class="imgPost-title-url">sandral strohschein fine art</a></strong><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f448.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f448.png?v8">👈</span></p>
<p><img src="/posts/./Dec-18-blog-02/sandralstrohscheinfineart/1.jpg" alt="sandralstrohscheinfineart-1"></p>
<p><img src="/posts/./Dec-18-blog-02/sandralstrohscheinfineart/2.jpg" alt="sandralstrohscheinfineart-2"></p>
<p>插画师Sandra Strohschein，是一位美国的水彩画艺术家。她的作品“马可岛日落”将与今天最受尊敬的水彩画家一起被收入2017年的Splash中。</p>
<p>4、<strong><a href="http://www.iraville.de" target="_blank" rel="noopener" class="imgPost-title-url">iraville</a></strong><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f448.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f448.png?v8">👈</span></p>
<p><img src="/posts/./Dec-18-blog-02/iraville/1.gif" alt="iraville-1"></p>
<p><img src="/posts/./Dec-18-blog-02/iraville/2.jpg" alt="iraville-2"></p>
<p><img src="/posts/./Dec-18-blog-02/iraville/3.jpg" alt="iraville-3"></p>
<p> 这是一位来自德国的插画师 Ira Sluyterman van Langeweyde，有一本画集叫做《Cozy Days: The Art of Iraville》。（现已加入本人的愿望书单，不过真的好贵<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8">😂</span>）</p>
<p>5、<strong><a href="http://paperblue.net" target="_blank" rel="noopener" class="imgPost-title-url">paperblue</a></strong><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f448.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f448.png?v8">👈</span></p>
<p><img src="/posts/./Dec-18-blog-02/paperblue/1.jpg" alt="paperblue-1"></p>
<p><img src="/posts/./Dec-18-blog-02/paperblue/2.jpg" alt="paperblue-2"></p>
<p><img src="/posts/./Dec-18-blog-02/paperblue/3.jpg" alt="paperblue-3"></p>
<p>作者 Park Jae-chul，一名在韩国工作的概念艺术家，以建筑，机架，背景居多。非常有趣。Paper Blue 是他的昵称。</p>
<h2 id="Dribble"><a href="#Dribble" class="headerlink" title="Dribble"></a><strong>Dribble</strong></h2><hr>

<p> 这里是从Dribbble上面收集，希望给做界面设计的时候，能给到一些启发。</p>
<p>1、<strong><a href="https://dribbble.com/shots/5647953-Food-Delivery-App?utm_campaign=2018-12-10&amp;utm_medium=email&amp;utm_source=repla" target="_blank" rel="noopener" class="imgPost-title-url">Food Delivery APP</a></strong><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f448.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f448.png?v8">👈</span></p>
<p><img src="/posts/./Dec-18-blog-02/dribble/1.png" alt="dribble-1"></p>
<p>2、<strong><a href="https://dribbble.com/shots/5683875-Home-Physical-Training-App" target="_blank" rel="noopener" class="imgPost-title-url">Home-Physical-Training-App</a></strong><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f448.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f448.png?v8">👈</span></p>
<p><img src="/posts/./Dec-18-blog-02/dribble/2.png" alt="dribble-2"></p>
<p>3、<strong><a href="https://dribbble.com/shots/5695843-Illustration-for-landing-page" target="_blank" rel="noopener" class="imgPost-title-url">Illustration for landing page</a></strong><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f448.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f448.png?v8">👈</span></p>
<p><img src="/posts/./Dec-18-blog-02/dribble/3.jpg" alt="dribble-3"></p>
<p>4、<strong><a href="https://dribbble.com/shots/5701809-Landing-Page" target="_blank" rel="noopener" class="imgPost-title-url">Landing Page</a></strong><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f448.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f448.png?v8">👈</span></p>
<p><img src="/posts/./Dec-18-blog-02/dribble/4.png" alt="dribble-4"></p>
<p>5、<strong><a href="https://dribbble.com/shots/5700321-Balance-Refill-Flow-for-Lifecell-App" target="_blank" rel="noopener" class="imgPost-title-url">Balance Refill Flow for Lifecell App</a></strong><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f448.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f448.png?v8">👈</span></p>
<p><img src="/posts/./Dec-18-blog-02/dribble/5.png" alt="dribble-5"></p>
<h2 id="有趣及清单"><a href="#有趣及清单" class="headerlink" title="有趣及清单"></a><strong>有趣及清单</strong></h2><hr>

<p>1、<strong><a href="https://github.com/MisterBooo/LeetCodeAnimation" target="_blank" rel="noopener" class="imgPost-title-url">尝试着将 LeetCode 上的题目用动画的形式解出来</a></strong><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f448.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f448.png?v8">👈</span></p>
<p><img src="/posts/./Dec-18-blog-02/other/1.gif" alt="other-1"></p>
<p>2、<strong><a href="https://github.com/onlynight/FlappyBird" target="_blank" rel="noopener" class="imgPost-title-url">微信小程序 FlappyBird</a></strong><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f448.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f448.png?v8">👈</span></p>
<p><img src="/posts/./Dec-18-blog-02/other/2.jpg" alt="other-2"></p>
<p>3、<strong><a href="https://crossoverjie.top/2018/12/12/java-senior/java-memary-allocation/" target="_blank" rel="noopener" class="imgPost-title-url">没错，老板让我写个 BUG！</a></strong><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f448.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f448.png?v8">👈</span></p>
<p><img src="/posts/./Dec-18-blog-02/other/3.jpg" alt="other-3"></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>绘画</tag>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title>Feb-19-blog-01</title>
    <url>/posts/Feb-19-blog-01.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="/posts/./Feb-19-blog-01/top.jpg" alt="Chien Chung-Wei"></p>
<a id="more"></a>
<h2 id="绘画"><a href="#绘画" class="headerlink" title="绘画"></a><strong>绘画</strong></h2><hr>

<p>点击标题即可跳转相应的站点</p>
<p>1、<strong><a href="https://www.witchoria.com/" target="_blank" class="imgPost-title-url">witchoria</a></strong><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f448.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f448.png?v8">👈</span></p>
<p><img src="/posts/./Feb-19-blog-01/witchoria/1.jpg" alt="witchoria"></p>
<p><img src="/posts/./Feb-19-blog-01/witchoria/2.jpg" alt="witchoria"></p>
<p><img src="/posts/./Feb-19-blog-01/witchoria/3.jpg" alt="witchoria"></p>
<p>​    Witchoria是一位视觉艺术家，想居住于纽约的布鲁克林区。主要从事于数字领域，创造超现实的图片，其中集中展示出她对倦怠，现有的危机和极度伤心的理解。她的作品曾在一些数字杂志中刊登，主要如下：<code>Wired</code>，<code>Juxtapoz</code>， <code>Huffington Post</code>，<code>Cosmopolitan</code>， <code>The Guardian</code>，还有<code>Business Insider</code>。</p>
<p>2、<strong><a href="https://www.beatriceblue.net/" target="_blank" class="imgPost-title-url">beatrice blue</a></strong><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f448.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f448.png?v8">👈</span></p>
<p><img src="/posts/./Feb-19-blog-01/beatriceblue/1.jpg" alt="beatriceblue"></p>
<p><img src="/posts/./Feb-19-blog-01/beatriceblue/2.jpg" alt="beatriceblue"></p>
<p><img src="/posts/./Feb-19-blog-01/beatriceblue/3.jpg" alt="beatriceblue"></p>
<p><img src="/posts/./Feb-19-blog-01/beatriceblue/4.jpg" alt="beatriceblue"></p>
<p><img src="/posts/./Feb-19-blog-01/beatriceblue/5.jpg" alt="beatriceblue"></p>
<p><img src="/posts/./Feb-19-blog-01/beatriceblue/6.jpg" alt="beatriceblue"></p>
<p><img src="/posts/./Feb-19-blog-01/beatriceblue/7.jpg" alt="beatriceblue"></p>
<p>​    beatrice blue是一位喜欢旅行和探索的自由视觉开发艺术家和插画家。以下是以前的和最近合作的公司：<code>Harper Collins</code>，<code>Nickelodeon</code>，<code>Huion</code>，<code>Dreamworks TV</code>，<code>Procreate</code>，<code>3D total</code>，<code>Lightbox Animation</code>，<code>Frances Lincoln</code>，<code>Literatura SM</code>，<code>Houghton Mifflin Harcourt</code>，<code>Lonely Planet</code>和<code>Quarto</code>等等。</p>
<p>3、<strong><a href="https://trishaadams.com" target="_blank" class="imgPost-title-url">trisha adams</a></strong><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f448.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f448.png?v8">👈</span></p>
<p><img src="/posts/./Feb-19-blog-01/trishaadams/1.jpg" alt="trisha adams"></p>
<p><img src="/posts/./Feb-19-blog-01/trishaadams/5.jpg" alt="trisha adams"></p>
<p><img src="/posts/./Feb-19-blog-01/trishaadams/2.jpg" alt="trisha adams"></p>
<p><img src="/posts/./Feb-19-blog-01/trishaadams/3.jpg" alt="trisha adams"></p>
<p><img src="/posts/./Feb-19-blog-01/trishaadams/4.jpg" alt="trisha adams"></p>
<p>​    Trisha Adams是一位印象派画家，来自美国加州。</p>
<p>4、<strong><a href="http://juanbernabeu.com" target="_blank" class="imgPost-title-url">juan bernabeu</a></strong><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f448.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f448.png?v8">👈</span></p>
<p><img src="/posts/./Feb-19-blog-01/juanbernabeu/1.jpg" alt="juan bernabeu"></p>
<p><img src="/posts/./Feb-19-blog-01/juanbernabeu/2.jpg" alt="juan bernabeu"></p>
<p><img src="/posts/./Feb-19-blog-01/juanbernabeu/3.jpg" alt="juan bernabeu"></p>
<p><img src="/posts/./Feb-19-blog-01/juanbernabeu/4.jpg" alt="juan bernabeu"></p>
<p><img src="/posts/./Feb-19-blog-01/juanbernabeu/5.jpg" alt="juan bernabeu"></p>
<p>​    juan bernabeu是一位出版物和图书的插画师。</p>
<p>5、<strong><a href="https://www.robinhar.com" target="_blank" class="imgPost-title-url">robin har</a></strong><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f448.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f448.png?v8">👈</span></p>
<p><img src="/posts/./Feb-19-blog-01/robinhar/1.jpg" alt="robinhar"></p>
<p><img src="/posts/./Feb-19-blog-01/robinhar/3.jpg" alt="robinhar"></p>
<p><img src="/posts/./Feb-19-blog-01/robinhar/7.jpg" alt="robinhar"></p>
<p><img src="/posts/./Feb-19-blog-01/robinhar/6.jpg" alt="robinhar"></p>
<p><img src="/posts/./Feb-19-blog-01/robinhar/4.jpg" alt="robinhar"></p>
<p><img src="/posts/./Feb-19-blog-01/robinhar/2.jpg" alt="robinhar"></p>
<p>​    robin har是<code>Viromedia</code>的联合创始人和首席创意官，是海报艺术家，是亚马逊的视觉设计师。</p>
<h2 id="APP设计"><a href="#APP设计" class="headerlink" title="APP设计"></a><strong>APP设计</strong></h2><hr>

<p>在Dribbble上收集的设计素材</p>
<p>1、<strong><a href="https://dribbble.com/shots/5924833-Smart-Home-App" target="_blank" class="imgPost-title-url">Smart Home App</a></strong><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f448.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f448.png?v8">👈</span></p>
<p><img src="/posts/./Feb-19-blog-01/dribbble/1.png" alt="dribbble"></p>
<p>2、<strong><a href="https://dribbble.com/shots/5923205-Currency-exchange-platform" target="_blank" class="imgPost-title-url">Currency exchange platform</a></strong><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f448.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f448.png?v8">👈</span></p>
<p><img src="/posts/./Feb-19-blog-01/dribbble/2.png" alt="dribbble"></p>
<p>3、<strong><a href="https://dribbble.com/shots/5963782-Elimisto-Messages" target="_blank" class="imgPost-title-url">Elimisto - Messages</a></strong><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f448.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f448.png?v8">👈</span></p>
<p><img src="/posts/./Feb-19-blog-01/dribbble/3.png" alt="dribbble"></p>
<p>4、<strong><a href="https://dribbble.com/shots/5965934-Customer-Dashboard-CRM" target="_blank" class="imgPost-title-url">Customer Dashboard - CRM</a></strong><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f448.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f448.png?v8">👈</span></p>
<p><img src="/posts/./Feb-19-blog-01/dribbble/4.png" alt="dribbble"></p>
<p>5、<strong><a href="https://dribbble.com/shots/5923382-Sweep-Travel-System" target="_blank" class="imgPost-title-url">Sweep Travel System</a></strong><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f448.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f448.png?v8">👈</span></p>
<p><img src="/posts/./Feb-19-blog-01/dribbble/5.png" alt="dribbble"></p>
<h2 id="有趣及清单"><a href="#有趣及清单" class="headerlink" title="有趣及清单"></a><strong>有趣及清单</strong></h2><hr>

<p>近期收集的有趣的东西</p>
<p>1、<strong><a href="https://gitnoteapp.com/" target="_blank" class="imgPost-title-url">GitNote</a></strong><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f448.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f448.png?v8">👈</span></p>
<p>介绍：<code>GitNote</code> 基于 <code>Git</code> 的跨平台笔记软件,内置<code>Git</code>同步,支持 <code>todo</code> 管理,支持富文本,<code>markdown</code> 编辑,支持思维脑图,流程图,多图床等等功能。</p>
<p>2、<strong><a href="https://zhuanlan.zhihu.com/p/56226189" target="_blank" class="imgPost-title-url">LeetCode for VS Code</a></strong><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f448.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f448.png?v8">👈</span></p>
<p>可以刷<code>LeetCode</code>的插件</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>绘画</tag>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript 基础类型</title>
    <url>/posts/typescript-basic-types.html</url>
    <content><![CDATA[<blockquote>
<p> TypeScript 支持与 JavaScript 几乎相同的数据类型，同时还提供了枚举类型</p>
</blockquote>
<a id="more"></a>
<h1 id="布尔值-boolean"><a href="#布尔值-boolean" class="headerlink" title="布尔值 boolean"></a>布尔值 boolean</h1><figure class="highlight typescript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> isDone: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br></pre></td></tr></tbody></table></figure>
<h1 id="数字-number"><a href="#数字-number" class="headerlink" title="数字 number"></a>数字 number</h1><p>支持二进制、八进制 、十进制、十六进制</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">let decLiteral: number = 6;</span><br><span class="line">let hexLiteral: number = 0xf00d;</span><br><span class="line">let binaryLiteral: number = 0b1010;</span><br><span class="line">let octalLiteral: number = 0o744;</span><br></pre></td></tr></tbody></table></figure>
<h1 id="字符串-string"><a href="#字符串-string" class="headerlink" title="字符串 string"></a>字符串 string</h1><figure class="highlight typescript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name: <span class="built_in">string</span> = <span class="string">"bob"</span>;</span><br><span class="line">name = <span class="string">"smith"</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>可以使用 <strong>模板字符串</strong> 定义多行文本和内嵌表达式，需要被  <strong>`</strong>  包围，以 <code>${ expr }</code>嵌入表达式</p>
<figure class="highlight typescript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name: <span class="built_in">string</span> = <span class="string">`Gene`</span>;</span><br><span class="line"><span class="keyword">let</span> age: <span class="built_in">number</span> = <span class="number">37</span>;</span><br><span class="line"><span class="keyword">let</span> sentence: <span class="built_in">string</span> = <span class="string">`Hello, my name is <span class="subst">${ name }</span>. I'll be <span class="subst">${ age + 1 }</span> years old next month.`</span>;</span><br></pre></td></tr></tbody></table></figure>
<p> 也可以这样写：</p>
<figure class="highlight typescript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sentence: <span class="built_in">string</span> = <span class="string">"Hello, my name is "</span> + name  + <span class="string">". I'll be "</span> + (age + <span class="number">1</span>) + <span class="string">" years old next month."</span>;</span><br></pre></td></tr></tbody></table></figure>
<h1 id="数组-Array-lt-gt"><a href="#数组-Array-lt-gt" class="headerlink" title="数组 [ ] / Array< >"></a>数组 [ ] / Array&lt; &gt;</h1><p>第一种方式，在类型后面接上<code>[ ]</code>，以此声明数组</p>
<figure class="highlight typescript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> list: <span class="built_in">number</span>[] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> strList: <span class="built_in">string</span>[] = [<span class="string">'aa'</span>,<span class="string">'bb'</span>,<span class="string">'cc'</span>];</span><br><span class="line"><span class="keyword">let</span> booleanList: <span class="built_in">boolean</span>[] = [<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">true</span>];</span><br></pre></td></tr></tbody></table></figure>
<p>第二种方式，泛型数组，<code>Array&lt;元素类型&gt;</code></p>
<figure class="highlight typescript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> list: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></tbody></table></figure>
<h1 id="元组-Tuple"><a href="#元组-Tuple" class="headerlink" title="元组 Tuple"></a>元组 Tuple</h1><p>表示一个已知元素数量和类型的数组，各元素类型可不同</p>
<figure class="highlight typescript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Declare a tuple type</span></span><br><span class="line"><span class="keyword">let</span> x: [<span class="built_in">string</span>, <span class="built_in">number</span>];</span><br><span class="line"><span class="comment">// Initialize it</span></span><br><span class="line">x = [<span class="string">'hello'</span>, <span class="number">10</span>]; <span class="comment">// OK</span></span><br><span class="line"><span class="comment">// Initialize it incorrectly</span></span><br><span class="line">x = [<span class="number">10</span>, <span class="string">'hello'</span>]; <span class="comment">// Error</span></span><br></pre></td></tr></tbody></table></figure>
<p>当访问一个已知索引的元素，会得到正确的类型：</p>
<figure class="highlight typescript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(x[<span class="number">0</span>].substr(<span class="number">1</span>)); <span class="comment">// OK</span></span><br><span class="line"><span class="built_in">console</span>.log(x[<span class="number">1</span>].substr(<span class="number">1</span>)); <span class="comment">// Error, 'number' does not have 'substr'</span></span><br></pre></td></tr></tbody></table></figure>
<p>当访问一个越界的元素，会使用联合类型替代：</p>
<figure class="highlight typescript"><table><tbody><tr><td class="code"><pre><span class="line">x[<span class="number">3</span>] = <span class="string">'world'</span>; <span class="comment">// OK, 字符串可以赋值给(string | number)类型</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x[<span class="number">5</span>].toString()); <span class="comment">// OK, 'string' 和 'number' 都有 toString</span></span><br><span class="line"></span><br><span class="line">x[<span class="number">6</span>] = <span class="literal">true</span>; <span class="comment">// Error, 布尔不是(string | number)类型</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="枚举-enum"><a href="#枚举-enum" class="headerlink" title="枚举 enum"></a>枚举 enum</h1><figure class="highlight typescript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color {Red, Green, Blue}</span><br><span class="line"><span class="keyword">let</span> c: Color = Color.Green;</span><br></pre></td></tr></tbody></table></figure>
<p>默认情况下，从<code>0</code>开始为元素编号。 你也可以手动的指定成员的数值。 例如，我们将上面的例子改成从 <code>1</code>开始编号：</p>
<figure class="highlight typescript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color {Red = <span class="number">1</span>, Green, Blue}</span><br><span class="line"><span class="keyword">let</span> c: Color = Color.Green;</span><br></pre></td></tr></tbody></table></figure>
<p>或者，全部都采用手动赋值：</p>
<figure class="highlight typescript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color {Red = <span class="number">1</span>, Green = <span class="number">2</span>, Blue = <span class="number">4</span>}</span><br><span class="line"><span class="keyword">let</span> c: Color = Color.Green;</span><br></pre></td></tr></tbody></table></figure>
<p>枚举类型提供的一个便利是你可以由枚举的值得到它的名字。 例如，我们知道数值为2，但是不确定它映射到Color里的哪个名字，我们可以查找相应的名字：</p>
<figure class="highlight typescript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color {Red = <span class="number">1</span>, Green, Blue}</span><br><span class="line"><span class="keyword">let</span> colorName: <span class="built_in">string</span> = Color[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(colorName);  <span class="comment">// 显示'Green'因为上面代码里它的值是2</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="any"><a href="#any" class="headerlink" title="any"></a>any</h1><figure class="highlight typescript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> notSure: <span class="built_in">any</span> = <span class="number">4</span>;</span><br><span class="line">notSure = <span class="string">"maybe a string instead"</span>;</span><br><span class="line">notSure = <span class="literal">false</span>; <span class="comment">// okay, definitely a boolean</span></span><br></pre></td></tr></tbody></table></figure>
<p>any  与 Object 虽然相似，但是也有不同之处：</p>
<figure class="highlight typescript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> notSure: <span class="built_in">any</span> = <span class="number">4</span>;</span><br><span class="line">notSure.ifItExists(); <span class="comment">// okay, if It Exists might exist at runtime</span></span><br><span class="line">notSure.toFixed(); <span class="comment">// okay, toFixed exists (but the compiler doesn't check)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> prettySure: <span class="built_in">Object</span> = <span class="number">4</span>;</span><br><span class="line">prettySure.toFixed(); <span class="comment">// Error: Property 'toFixed' doesn't exist on type 'Object'.</span></span><br></pre></td></tr></tbody></table></figure>
<p>当你只知道一部分数据的类型时，<code>any</code>类型也是有用的</p>
<figure class="highlight typescript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> list: <span class="built_in">any</span>[] = [<span class="number">1</span>, <span class="literal">true</span>, <span class="string">"free"</span>];</span><br><span class="line"></span><br><span class="line">list[<span class="number">1</span>] = <span class="number">100</span>;</span><br></pre></td></tr></tbody></table></figure>
<h1 id="void"><a href="#void" class="headerlink" title="void"></a>void</h1><p>某种程度上来说，<code>void</code>类型像是与<code>any</code>类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 <code>void</code>：</p>
<figure class="highlight ts"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">warnUser</span>(<span class="params"></span>): <span class="title">void</span> </span>{</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"This is my warning message"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>声明一个<code>void</code>类型的变量没有什么大用，因为你只能为它赋予<code>undefined</code>和<code>null</code>：</p>
<figure class="highlight ts"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> unusable: <span class="built_in">void</span> = <span class="literal">undefined</span>;</span><br></pre></td></tr></tbody></table></figure>
<h1 id="Null-和-Undefined"><a href="#Null-和-Undefined" class="headerlink" title="Null 和 Undefined"></a>Null 和 Undefined</h1><p>TypeScript里，<code>undefined</code>和<code>null</code>两者各自有自己的类型分别叫做<code>undefined</code>和<code>null</code>。 和 <code>void</code>相似，它们的本身的类型用处不是很大：</p>
<figure class="highlight ts"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Not much else we can assign to these variables!</span></span><br><span class="line"><span class="keyword">let</span> u: <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> n: <span class="literal">null</span> = <span class="literal">null</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>默认情况下<code>null</code>和<code>undefined</code>是所有类型的子类型。 就是说你可以把 <code>null</code>和<code>undefined</code>赋值给<code>number</code>类型的变量。</p>
<p>然而，当你指定了<code>--strictNullChecks</code>标记，<code>null</code>和<code>undefined</code>只能赋值给<code>void</code>和它们各自。 这能避免 <em>很多</em>常见的问题。 也许在某处你想传入一个 <code>string</code>或<code>null</code>或<code>undefined</code>，你可以使用联合类型<code>string | null | undefined</code>。 </p>
<h1 id="Never"><a href="#Never" class="headerlink" title="Never"></a>Never</h1><p><code>never</code>类型表示的是那些永不存在的值的类型。 例如， <code>never</code>类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 <code>never</code>类型，当它们被永不为真的类型保护所约束时。</p>
<p><code>never</code>类型是任何类型的子类型，也可以赋值给任何类型；然而，<em>没有</em>类型是<code>never</code>的子类型或可以赋值给<code>never</code>类型（除了<code>never</code>本身之外）。 即使 <code>any</code>也不可以赋值给<code>never</code>。</p>
<p>下面是一些返回<code>never</code>类型的函数：</p>
<figure class="highlight ts"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 返回never的函数必须存在无法达到的终点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">error</span>(<span class="params">message: <span class="built_in">string</span></span>): <span class="title">never</span> </span>{</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(message);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推断的返回值类型为never</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fail</span>(<span class="params"></span>) </span>{</span><br><span class="line">    <span class="keyword">return</span> error(<span class="string">"Something failed"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回never的函数必须存在无法达到的终点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">infiniteLoop</span>(<span class="params"></span>): <span class="title">never</span> </span>{</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h1 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h1><p><code>object</code>表示非原始类型，也就是除<code>number</code>，<code>string</code>，<code>boolean</code>，<code>symbol</code>，<code>null</code>或<code>undefined</code>之外的类型。</p>
<p>使用<code>object</code>类型，就可以更好的表示像<code>Object.create</code>这样的API</p>
<figure class="highlight ts"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">o: object | <span class="literal">null</span></span>): <span class="title">void</span></span>;</span><br><span class="line"></span><br><span class="line">create({ prop: <span class="number">0</span> }); <span class="comment">// OK</span></span><br><span class="line">create(<span class="literal">null</span>); <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line">create(<span class="number">42</span>); <span class="comment">// Error</span></span><br><span class="line">create(<span class="string">"string"</span>); <span class="comment">// Error</span></span><br><span class="line">create(<span class="literal">false</span>); <span class="comment">// Error</span></span><br><span class="line">create(<span class="literal">undefined</span>); <span class="comment">// Error</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h1><p>有时候你会遇到这样的情况，你会比TypeScript更了解某个值的详细信息。 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。</p>
<p>通过<em>类型断言</em>这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript会假设你，程序员，已经进行了必须的检查。</p>
<p>类型断言有两种形式。 其一是“尖括号”语法：</p>
<figure class="highlight ts"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> someValue: <span class="built_in">any</span> = <span class="string">"this is a string"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> strLength: <span class="built_in">number</span> = (&lt;<span class="built_in">string</span>&gt;someValue).length;</span><br></pre></td></tr></tbody></table></figure>
<p>另一个为<code>as</code>语法：</p>
<figure class="highlight ts"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> someValue: <span class="built_in">any</span> = <span class="string">"this is a string"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> strLength: <span class="built_in">number</span> = (someValue <span class="keyword">as</span> <span class="built_in">string</span>).length;</span><br></pre></td></tr></tbody></table></figure>
<p>两种形式是等价的。 至于使用哪个大多数情况下是凭个人喜好；然而，当你在TypeScript里使用JSX时，只有 <code>as</code>语法断言是被允许的。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>typescript</tag>
      </tags>
  </entry>
  <entry>
    <title>Mar-19-blog-01</title>
    <url>/posts/Mar-19-blog-01.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近几天，天空像是把双手插进装满云的蜜罐里，黏黏的，怎么抹都抹不掉。最后，跑到海边看日月贝。</p>
<p><img src="/posts/./Mar-19-blog-01/header/1.jpg" alt="Chien Chung-Wei"></p>
<a id="more"></a>
<p><img src="/posts/./Mar-19-blog-01/header/2.jpg" alt="Chien Chung-Wei"></p>
<p><img src="/posts/./Mar-19-blog-01/header/3.jpg" alt="Chien Chung-Wei"></p>
<p><img src="/posts/./Mar-19-blog-01/header/4.jpg" alt="Chien Chung-Wei"></p>
<h2 id="绘画"><a href="#绘画" class="headerlink" title="绘画"></a><strong>绘画</strong></h2><hr>

<p>以下是最近几天收集的</p>
<p>1、<strong><a href="#" target="_blank" class="imgPost-title-url">标题</a></strong><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f448.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f448.png?v8">👈</span></p>
<p>​    Nicholas Hely Hutchinson出身于1955年xxxx</p>
<p>2、<strong><a href="#" target="_blank" class="imgPost-title-url">标题</a></strong><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f448.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f448.png?v8">👈</span></p>
<p>​    xxxxx</p>
<p>3、<strong><a href="https://www.pandagun.com" target="_blank" rel="noopener" class="imgPost-title-url">标题</a></strong><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f448.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f448.png?v8">👈</span></p>
<p>​    xxxx</p>
<h2 id="博客画师"><a href="#博客画师" class="headerlink" title="博客画师"></a><strong>博客画师</strong></h2><hr>

<p>点击标题即可跳转相应的站点</p>
<h2 id="Dribble"><a href="#Dribble" class="headerlink" title="Dribble"></a><strong>Dribble</strong></h2><hr>

<p>点击标题即可跳转相应的站点</p>
<h2 id="有趣及清单"><a href="#有趣及清单" class="headerlink" title="有趣及清单"></a><strong>有趣及清单</strong></h2><hr>

<p>点击标题即可跳转相应的站点</p>
<p><strong>小结：</strong></p>
<p>​     xxxx</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>绘画</tag>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript 解构与展开</title>
    <url>/posts/typescript-variable-declarations.html</url>
    <content><![CDATA[<blockquote>
<p> 解构赋值语法是一种JavaScript表达式，可以将数组中的值或对象中的属性解压缩为不同的变量。</p>
</blockquote>
<a id="more"></a>
<h2 id="解构数组"><a href="#解构数组" class="headerlink" title="解构数组"></a>解构数组</h2><p>最简单的解构莫过于数组的解构赋值了：</p>
<figure class="highlight ts"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> input = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> [first, second] = input;</span><br><span class="line"><span class="built_in">console</span>.log(first); <span class="comment">// outputs 1</span></span><br><span class="line"><span class="built_in">console</span>.log(second); <span class="comment">// outputs 2</span></span><br></pre></td></tr></tbody></table></figure>
<p>这创建了2个命名变量 <code>first</code> 和 <code>second</code>。 相当于使用了索引，但更为方便：</p>
<figure class="highlight ts"><table><tbody><tr><td class="code"><pre><span class="line">first = input[<span class="number">0</span>];</span><br><span class="line">second = input[<span class="number">1</span>];</span><br></pre></td></tr></tbody></table></figure>
<p>解构作用于已声明的变量会更好：</p>
<figure class="highlight ts"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// swap variables</span></span><br><span class="line">[first, second] = [second, first];</span><br></pre></td></tr></tbody></table></figure>
<p>作用于函数参数：</p>
<figure class="highlight ts"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[first, second]: [<span class="built_in">number</span>, <span class="built_in">number</span>]</span>) </span>{</span><br><span class="line">    <span class="built_in">console</span>.log(first);</span><br><span class="line">    <span class="built_in">console</span>.log(second);</span><br><span class="line">}</span><br><span class="line">f(input);</span><br></pre></td></tr></tbody></table></figure>
<p>你可以在数组里使用<code>...</code>语法创建剩余变量：</p>
<figure class="highlight ts"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [first, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="built_in">console</span>.log(first); <span class="comment">// outputs 1</span></span><br><span class="line"><span class="built_in">console</span>.log(rest); <span class="comment">// outputs [ 2, 3, 4 ]</span></span><br></pre></td></tr></tbody></table></figure>
<p>当然，由于是JavaScript, 你可以忽略你不关心的尾随元素：</p>
<figure class="highlight ts"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [first] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="built_in">console</span>.log(first); <span class="comment">// outputs 1</span></span><br></pre></td></tr></tbody></table></figure>
<p>或其它元素：</p>
<figure class="highlight ts"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [, second, , fourth] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br></pre></td></tr></tbody></table></figure>
<h2 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h2><p>你也可以解构对象：</p>
<figure class="highlight ts"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> o = {</span><br><span class="line">    a: <span class="string">"foo"</span>,</span><br><span class="line">    b: <span class="number">12</span>,</span><br><span class="line">    c: <span class="string">"bar"</span></span><br><span class="line">};</span><br><span class="line"><span class="keyword">let</span> { a, b } = o;</span><br></pre></td></tr></tbody></table></figure>
<p>这通过 <code>o.a</code> and <code>o.b</code> 创建了 <code>a</code> 和 <code>b</code> 。 注意，如果你不需要 <code>c</code> 你可以忽略它。</p>
<p>就像数组解构，你可以用没有声明的赋值：</p>
<figure class="highlight ts"><table><tbody><tr><td class="code"><pre><span class="line">({ a, b } = { a: <span class="string">"baz"</span>, b: <span class="number">101</span> });</span><br></pre></td></tr></tbody></table></figure>
<p>注意，我们需要用括号将它括起来，因为Javascript通常会将以 <code>{</code> 起始的语句解析为一个块。</p>
<p>你可以在对象里使用<code>...</code>语法创建剩余变量：</p>
<figure class="highlight ts"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> { a, ...passthrough } = o;</span><br><span class="line"><span class="keyword">let</span> total = passthrough.b + passthrough.c.length;</span><br></pre></td></tr></tbody></table></figure>
<h3 id="属性重命名"><a href="#属性重命名" class="headerlink" title="属性重命名"></a>属性重命名</h3><p>你也可以给属性以不同的名字：</p>
<figure class="highlight ts"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> { a: newName1, b: newName2 } = o;</span><br></pre></td></tr></tbody></table></figure>
<p>这里的语法开始变得混乱。 你可以将 <code>a: newName1</code> 读做 “<code>a</code> 作为 <code>newName1</code>“。 方向是从左到右，好像你写成了以下样子：</p>
<figure class="highlight ts"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> newName1 = o.a;</span><br><span class="line"><span class="keyword">let</span> newName2 = o.b;</span><br></pre></td></tr></tbody></table></figure>
<p>令人困惑的是，这里的冒号<em>不是</em>指示类型的。 如果你想指定它的类型， 仍然需要在其后写上完整的模式。</p>
<figure class="highlight ts"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> {a, b}: {a: <span class="built_in">string</span>, b: <span class="built_in">number</span>} = o;</span><br></pre></td></tr></tbody></table></figure>
<h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><p>默认值可以让你在属性为 undefined 时使用缺省值：</p>
<figure class="highlight ts"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">keepWholeObject</span>(<span class="params">wholeObject: { a: <span class="built_in">string</span>, b?: <span class="built_in">number</span> }</span>) </span>{</span><br><span class="line">    <span class="keyword">let</span> { a, b = <span class="number">1001</span> } = wholeObject;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>现在，即使 <code>b</code> 为 undefined ， <code>keepWholeObject</code> 函数的变量 <code>wholeObject</code> 的属性 <code>a</code> 和 <code>b</code> 都会有值。</p>
<h2 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h2><p>解构也能用于函数声明。 看以下简单的情况：</p>
<figure class="highlight ts"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> C = { a: <span class="built_in">string</span>, b?: <span class="built_in">number</span> }</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">{ a, b }: C</span>): <span class="title">void</span> </span>{</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>但是，通常情况下更多的是指定默认值，解构默认值有些棘手。 首先，你需要在默认值之前设置其格式。</p>
<figure class="highlight ts"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">{ a="", b=0 } = {}</span>): <span class="title">void</span> </span>{</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">}</span><br><span class="line">f();</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>上面的代码是一个类型推断的例子，将在本手册后文介绍。</p>
</blockquote>
<p>其次，你需要知道在解构属性上给予一个默认或可选的属性用来替换主初始化列表。 要知道 <code>C</code> 的定义有一个 <code>b</code> 可选属性：</p>
<figure class="highlight ts"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">{ a, b = 0 } = { a: "" }</span>): <span class="title">void</span> </span>{</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">}</span><br><span class="line">f({ a: <span class="string">"yes"</span> }); <span class="comment">// ok, default b = 0</span></span><br><span class="line">f(); <span class="comment">// ok, default to {a: ""}, which then defaults b = 0</span></span><br><span class="line">f({}); <span class="comment">// error, 'a' is required if you supply an argument</span></span><br></pre></td></tr></tbody></table></figure>
<p>要小心使用解构。 从前面的例子可以看出，就算是最简单的解构表达式也是难以理解的。 尤其当存在深层嵌套解构的时候，就算这时没有堆叠在一起的重命名，默认值和类型注解，也是令人难以理解的。 解构表达式要尽量保持小而简单。 你自己也可以直接使用解构将会生成的赋值表达式。</p>
<h2 id="展开"><a href="#展开" class="headerlink" title="展开"></a>展开</h2><p>展开操作符正与解构相反。 它允许你将一个数组展开为另一个数组，或将一个对象展开为另一个对象。 例如：</p>
<figure class="highlight ts"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> first = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> second = [<span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> bothPlus = [<span class="number">0</span>, ...first, ...second, <span class="number">5</span>];</span><br></pre></td></tr></tbody></table></figure>
<p>这会令<code>bothPlus</code>的值为<code>[0, 1, 2, 3, 4, 5]</code>。 展开操作创建了 <code>first</code>和<code>second</code>的一份浅拷贝。 它们不会被展开操作所改变。</p>
<p>你还可以展开对象：</p>
<figure class="highlight ts"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> defaults = { food: <span class="string">"spicy"</span>, price: <span class="string">"$$"</span>, ambiance: <span class="string">"noisy"</span> };</span><br><span class="line"><span class="keyword">let</span> search = { ...defaults, food: <span class="string">"rich"</span> };</span><br></pre></td></tr></tbody></table></figure>
<p><code>search</code>的值为<code>{ food: "rich", price: "$$", ambiance: "noisy" }</code>。 对象的展开比数组的展开要复杂的多。 像数组展开一样，它是从左至右进行处理，但结果仍为对象。 这就意味着出现在展开对象后面的属性会覆盖前面的属性。 因此，如果我们修改上面的例子，在结尾处进行展开的话：</p>
<figure class="highlight ts"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> defaults = { food: <span class="string">"spicy"</span>, price: <span class="string">"$$"</span>, ambiance: <span class="string">"noisy"</span> };</span><br><span class="line"><span class="keyword">let</span> search = { food: <span class="string">"rich"</span>, ...defaults };</span><br></pre></td></tr></tbody></table></figure>
<p>那么，<code>defaults</code>里的<code>food</code>属性会重写<code>food: "rich"</code>，在这里这并不是我们想要的结果。</p>
<p>对象展开还有其它一些意想不到的限制。 首先，它仅包含对象 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Enumerability_and_ownership_of_properties" target="_blank" rel="noopener">自身的可枚举属性</a>。 大体上是说当你展开一个对象实例时，你会丢失其方法：</p>
<figure class="highlight ts"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> C {</span><br><span class="line">  p = <span class="number">12</span>;</span><br><span class="line">  m() {</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> C();</span><br><span class="line"><span class="keyword">let</span> clone = { ...c };</span><br><span class="line">clone.p; <span class="comment">// ok</span></span><br><span class="line">clone.m(); <span class="comment">// error!</span></span><br></pre></td></tr></tbody></table></figure>
<p>其次，TypeScript编译器不允许展开泛型函数上的类型参数。 这个特性会在TypeScript的未来版本中考虑实现。</p>
<h1 id="资料来源"><a href="#资料来源" class="headerlink" title="资料来源"></a>资料来源</h1><p>1、变量声明 <a href="https://www.tslang.cn/docs/handbook/variable-declarations.html" target="_blank" rel="noopener">https://www.tslang.cn/docs/handbook/variable-declarations.html</a></p>
<p>2、表达式-解构分配 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment</a></p>
<p>3、变量的解构赋值 <a href="https://es6.ruanyifeng.com/#docs/destructuring" target="_blank" rel="noopener">https://es6.ruanyifeng.com/#docs/destructuring</a></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>typescript</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript 接口</title>
    <url>/posts/typescript-interfaces.html</url>
    <content><![CDATA[<p>TypeScript的核心原则之一是对值所具有的<em>结构</em>进行类型检查。 它有时被称做“鸭式辨型法”或“结构性子类型化”。 在TypeScript里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。</p>
<a id="more"></a>
<h1 id="接口初探"><a href="#接口初探" class="headerlink" title="接口初探"></a>接口初探</h1><p>下面通过一个简单示例来观察接口是如何工作的：</p>
<figure class="highlight ts"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printLabel</span>(<span class="params">labelledObj: { label: <span class="built_in">string</span> }</span>) </span>{</span><br><span class="line">  <span class="built_in">console</span>.log(labelledObj.label);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myObj = { size: <span class="number">10</span>, label: <span class="string">"Size 10 Object"</span> };</span><br><span class="line">printLabel(myObj);</span><br></pre></td></tr></tbody></table></figure>
<p>类型检查器会查看<code>printLabel</code>的调用。 <code>printLabel</code>有一个参数，并要求这个对象参数有一个名为<code>label</code>类型为<code>string</code>的属性。 需要注意的是，我们传入的对象参数实际上会包含很多属性，但是编译器只会检查那些必需的属性是否存在，并且其类型是否匹配。 然而，有些时候TypeScript却并不会这么宽松，我们下面会稍做讲解。</p>
<p>下面我们重写上面的例子，这次使用接口来描述：必须包含一个<code>label</code>属性且类型为<code>string</code>：</p>
<figure class="highlight ts"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> LabelledValue {</span><br><span class="line">  label: <span class="built_in">string</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printLabel</span>(<span class="params">labelledObj: LabelledValue</span>) </span>{</span><br><span class="line">  <span class="built_in">console</span>.log(labelledObj.label);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myObj = {size: <span class="number">10</span>, label: <span class="string">"Size 10 Object"</span>};</span><br><span class="line">printLabel(myObj);</span><br></pre></td></tr></tbody></table></figure>
<p><code>LabelledValue</code>接口就好比一个名字，用来描述上面例子里的要求。 它代表了有一个 <code>label</code>属性且类型为<code>string</code>的对象。 需要注意的是，我们在这里并不能像在其它语言里一样，说传给 <code>printLabel</code>的对象实现了这个接口。我们只会去关注值的外形。 只要传入的对象满足上面提到的必要条件，那么它就是被允许的。</p>
<p>还有一点值得提的是，类型检查器不会去检查属性的顺序，只要相应的属性存在并且类型也是对的就可以。</p>
<h1 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h1><p>接口里的属性不全都是必需的。 有些是只在某些条件下存在，或者根本不存在。 可选属性在应用“option bags”模式时很常用，即给函数传入的参数对象中只有部分属性赋值了。</p>
<p>下面是应用了“option bags”的例子：</p>
<figure class="highlight ts"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> SquareConfig {</span><br><span class="line">  color?: <span class="built_in">string</span>;</span><br><span class="line">  width?: <span class="built_in">number</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createSquare</span>(<span class="params">config: SquareConfig</span>): </span>{color: <span class="built_in">string</span>; area: <span class="built_in">number</span>} {</span><br><span class="line">  <span class="keyword">let</span> newSquare = {color: <span class="string">"white"</span>, area: <span class="number">100</span>};</span><br><span class="line">  <span class="keyword">if</span> (config.color) {</span><br><span class="line">    newSquare.color = config.color;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span> (config.width) {</span><br><span class="line">    newSquare.area = config.width * config.width;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> newSquare;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySquare = createSquare({color: <span class="string">"black"</span>});</span><br></pre></td></tr></tbody></table></figure>
<p>带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个<code>?</code>符号。</p>
<p>可选属性的好处之一是可以对可能存在的属性进行预定义，好处之二是可以捕获引用了不存在的属性时的错误。 比如，我们故意将 <code>createSquare</code>里的<code>color</code>属性名拼错，就会得到一个错误提示：</p>
<figure class="highlight ts"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> SquareConfig {</span><br><span class="line">  color?: <span class="built_in">string</span>;</span><br><span class="line">  width?: <span class="built_in">number</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createSquare</span>(<span class="params">config: SquareConfig</span>): </span>{ color: <span class="built_in">string</span>; area: <span class="built_in">number</span> } {</span><br><span class="line">  <span class="keyword">let</span> newSquare = {color: <span class="string">"white"</span>, area: <span class="number">100</span>};</span><br><span class="line">  <span class="keyword">if</span> (config.clor) {</span><br><span class="line">    <span class="comment">// Error: Property 'clor' does not exist on type 'SquareConfig'</span></span><br><span class="line">    newSquare.color = config.clor;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span> (config.width) {</span><br><span class="line">    newSquare.area = config.width * config.width;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> newSquare;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySquare = createSquare({color: <span class="string">"black"</span>});</span><br></pre></td></tr></tbody></table></figure>
<h1 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h1><p>一些对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用 <code>readonly</code>来指定只读属性:</p>
<figure class="highlight ts"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Point {</span><br><span class="line">    readonly x: <span class="built_in">number</span>;</span><br><span class="line">    readonly y: <span class="built_in">number</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>你可以通过赋值一个对象字面量来构造一个<code>Point</code>。 赋值后， <code>x</code>和<code>y</code>再也不能被改变了。</p>
<figure class="highlight ts"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1: Point = { x: <span class="number">10</span>, y: <span class="number">20</span> };</span><br><span class="line">p1.x = <span class="number">5</span>; <span class="comment">// error!</span></span><br></pre></td></tr></tbody></table></figure>
<p>TypeScript具有<code>ReadonlyArray</code>类型，它与<code>Array</code>相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改：</p>
<figure class="highlight ts"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> ro: ReadonlyArray&lt;<span class="built_in">number</span>&gt; = a;</span><br><span class="line">ro[<span class="number">0</span>] = <span class="number">12</span>; <span class="comment">// error!</span></span><br><span class="line">ro.push(<span class="number">5</span>); <span class="comment">// error!</span></span><br><span class="line">ro.length = <span class="number">100</span>; <span class="comment">// error!</span></span><br><span class="line">a = ro; <span class="comment">// error!</span></span><br></pre></td></tr></tbody></table></figure>
<p>上面代码的最后一行，可以看到就算把整个<code>ReadonlyArray</code>赋值到一个普通数组也是不可以的。 但是你可以用类型断言重写：</p>
<figure class="highlight ts"><table><tbody><tr><td class="code"><pre><span class="line">a = ro <span class="keyword">as</span> <span class="built_in">number</span>[];</span><br></pre></td></tr></tbody></table></figure>
<h2 id="readonly-vs-const"><a href="#readonly-vs-const" class="headerlink" title="readonly vs const"></a><code>readonly</code> vs <code>const</code></h2><p>最简单判断该用<code>readonly</code>还是<code>const</code>的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用 <code>const</code>，若做为属性则使用<code>readonly</code>。</p>
<h1 id="额外的属性检查"><a href="#额外的属性检查" class="headerlink" title="额外的属性检查"></a>额外的属性检查</h1><p>我们在第一个例子里使用了接口，TypeScript让我们传入<code>{ size: number; label: string; }</code>到仅期望得到<code>{ label: string; }</code>的函数里。 我们已经学过了可选属性，并且知道他们在“option bags”模式里很有用。</p>
<p>然而，天真地将这两者结合的话就会像在JavaScript里那样搬起石头砸自己的脚。 比如，拿 <code>createSquare</code>例子来说：</p>
<figure class="highlight ts"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> SquareConfig {</span><br><span class="line">    color?: <span class="built_in">string</span>;</span><br><span class="line">    width?: <span class="built_in">number</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createSquare</span>(<span class="params">config: SquareConfig</span>): </span>{ color: <span class="built_in">string</span>; area: <span class="built_in">number</span> } {</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySquare = createSquare({ colour: <span class="string">"red"</span>, width: <span class="number">100</span> });</span><br></pre></td></tr></tbody></table></figure>
<p>注意传入<code>createSquare</code>的参数拼写为<em><code>colour</code></em>而不是<code>color</code>。 在JavaScript里，这会默默地失败。</p>
<p>你可能会争辩这个程序已经正确地类型化了，因为<code>width</code>属性是兼容的，不存在<code>color</code>属性，而且额外的<code>colour</code>属性是无意义的。</p>
<p>然而，TypeScript会认为这段代码可能存在bug。 对象字面量会被特殊对待而且会经过 <em>额外属性检查</em>，当将它们赋值给变量或作为参数传递的时候。 如果一个对象字面量存在任何“目标类型”不包含的属性时，你会得到一个错误。</p>
<figure class="highlight ts"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// error: 'colour' not expected in type 'SquareConfig'</span></span><br><span class="line"><span class="keyword">let</span> mySquare = createSquare({ colour: <span class="string">"red"</span>, width: <span class="number">100</span> });</span><br></pre></td></tr></tbody></table></figure>
<p>绕开这些检查非常简单。 最简便的方法是使用类型断言：</p>
<figure class="highlight ts"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mySquare = createSquare({ width: <span class="number">100</span>, opacity: <span class="number">0.5</span> } <span class="keyword">as</span> SquareConfig);</span><br></pre></td></tr></tbody></table></figure>
<p>然而，最佳的方式是能够添加一个字符串索引签名，前提是你能够确定这个对象可能具有某些做为特殊用途使用的额外属性。 如果 <code>SquareConfig</code>带有上面定义的类型的<code>color</code>和<code>width</code>属性，并且<em>还会</em>带有任意数量的其它属性，那么我们可以这样定义它：</p>
<figure class="highlight ts"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> SquareConfig {</span><br><span class="line">    color?: <span class="built_in">string</span>;</span><br><span class="line">    width?: <span class="built_in">number</span>;</span><br><span class="line">    [propName: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>我们稍后会讲到索引签名，但在这我们要表示的是<code>SquareConfig</code>可以有任意数量的属性，并且只要它们不是<code>color</code>和<code>width</code>，那么就无所谓它们的类型是什么。</p>
<p>还有最后一种跳过这些检查的方式，这可能会让你感到惊讶，它就是将这个对象赋值给一个另一个变量： 因为 <code>squareOptions</code>不会经过额外属性检查，所以编译器不会报错。</p>
<figure class="highlight ts"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> squareOptions = { colour: <span class="string">"red"</span>, width: <span class="number">100</span> };</span><br><span class="line"><span class="keyword">let</span> mySquare = createSquare(squareOptions);</span><br></pre></td></tr></tbody></table></figure>
<p>要留意，在像上面一样的简单代码里，你可能不应该去绕开这些检查。 对于包含方法和内部状态的复杂对象字面量来讲，你可能需要使用这些技巧，但是大部额外属性检查错误是真正的bug。 就是说你遇到了额外类型检查出的错误，比如“option bags”，你应该去审查一下你的类型声明。 在这里，如果支持传入 <code>color</code>或<code>colour</code>属性到<code>createSquare</code>，你应该修改<code>SquareConfig</code>定义来体现出这一点。</p>
<h1 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h1><p>接口能够描述JavaScript中对象拥有的各种各样的外形。 除了描述带有属性的普通对象外，接口也可以描述函数类型。</p>
<p>为了使用接口表示函数类型，我们需要给接口定义一个调用签名。 它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。</p>
<figure class="highlight ts"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> SearchFunc {</span><br><span class="line">  (source: <span class="built_in">string</span>, subString: <span class="built_in">string</span>): <span class="built_in">boolean</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这样定义后，我们可以像使用其它接口一样使用这个函数类型的接口。 下例展示了如何创建一个函数类型的变量，并将一个同类型的函数赋值给这个变量。</p>
<figure class="highlight ts"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mySearch: SearchFunc;</span><br><span class="line">mySearch = <span class="function"><span class="keyword">function</span>(<span class="params">source: <span class="built_in">string</span>, subString: <span class="built_in">string</span></span>) </span>{</span><br><span class="line">  <span class="keyword">let</span> result = source.search(subString);</span><br><span class="line">  <span class="keyword">return</span> result &gt; <span class="number">-1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>对于函数类型的类型检查来说，函数的参数名不需要与接口里定义的名字相匹配。 比如，我们使用下面的代码重写上面的例子：</p>
<figure class="highlight ts"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mySearch: SearchFunc;</span><br><span class="line">mySearch = <span class="function"><span class="keyword">function</span>(<span class="params">src: <span class="built_in">string</span>, sub: <span class="built_in">string</span></span>): <span class="title">boolean</span> </span>{</span><br><span class="line">  <span class="keyword">let</span> result = src.search(sub);</span><br><span class="line">  <span class="keyword">return</span> result &gt; <span class="number">-1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>函数的参数会逐个进行检查，要求对应位置上的参数类型是兼容的。 如果你不想指定类型，TypeScript的类型系统会推断出参数类型，因为函数直接赋值给了 <code>SearchFunc</code>类型变量。 函数的返回值类型是通过其返回值推断出来的（此例是 <code>false</code>和<code>true</code>）。 如果让这个函数返回数字或字符串，类型检查器会警告我们函数的返回值类型与 <code>SearchFunc</code>接口中的定义不匹配。</p>
<figure class="highlight ts"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mySearch: SearchFunc;</span><br><span class="line">mySearch = <span class="function"><span class="keyword">function</span>(<span class="params">src, sub</span>) </span>{</span><br><span class="line">    <span class="keyword">let</span> result = src.search(sub);</span><br><span class="line">    <span class="keyword">return</span> result &gt; <span class="number">-1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h1 id="可索引的类型"><a href="#可索引的类型" class="headerlink" title="可索引的类型"></a>可索引的类型</h1><p>与使用接口描述函数类型差不多，我们也可以描述那些能够“通过索引得到”的类型，比如<code>a[10]</code>或<code>ageMap["daniel"]</code>。 可索引类型具有一个 <em>索引签名</em>，它描述了对象索引的类型，还有相应的索引返回值类型。 让我们看一个例子：</p>
<figure class="highlight ts"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> StringArray {</span><br><span class="line">  [index: <span class="built_in">number</span>]: <span class="built_in">string</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myArray: StringArray;</span><br><span class="line">myArray = [<span class="string">"Bob"</span>, <span class="string">"Fred"</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myStr: <span class="built_in">string</span> = myArray[<span class="number">0</span>];</span><br></pre></td></tr></tbody></table></figure>
<p>上面例子里，我们定义了<code>StringArray</code>接口，它具有索引签名。 这个索引签名表示了当用 <code>number</code>去索引<code>StringArray</code>时会得到<code>string</code>类型的返回值。</p>
<p>TypeScript支持两种索引签名：字符串和数字。 可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。 这是因为当使用 <code>number</code>来索引时，JavaScript会将它转换成<code>string</code>然后再去索引对象。 也就是说用 <code>100</code>（一个<code>number</code>）去索引等同于使用<code>"100"</code>（一个<code>string</code>）去索引，因此两者需要保持一致。</p>
<figure class="highlight ts"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Animal {</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">class</span> Dog <span class="keyword">extends</span> Animal {</span><br><span class="line">    breed: <span class="built_in">string</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误：使用数值型的字符串索引，有时会得到完全不同的Animal!</span></span><br><span class="line"><span class="keyword">interface</span> NotOkay {</span><br><span class="line">    [x: <span class="built_in">number</span>]: Animal;</span><br><span class="line">    [x: <span class="built_in">string</span>]: Dog;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>字符串索引签名能够很好的描述<code>dictionary</code>模式，并且它们也会确保所有属性与其返回值类型相匹配。 因为字符串索引声明了 <code>obj.property</code>和<code>obj["property"]</code>两种形式都可以。 下面的例子里， <code>name</code>的类型与字符串索引类型不匹配，所以类型检查器给出一个错误提示：</p>
<figure class="highlight ts"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> NumberDictionary {</span><br><span class="line">  [index: <span class="built_in">string</span>]: <span class="built_in">number</span>;</span><br><span class="line">  length: <span class="built_in">number</span>;    <span class="comment">// 可以，length是number类型</span></span><br><span class="line">  name: <span class="built_in">string</span>       <span class="comment">// 错误，`name`的类型与索引类型返回值的类型不匹配</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>最后，你可以将索引签名设置为只读，这样就防止了给索引赋值：</p>
<figure class="highlight ts"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> ReadonlyStringArray {</span><br><span class="line">    readonly [index: <span class="built_in">number</span>]: <span class="built_in">string</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">let</span> myArray: ReadonlyStringArray = [<span class="string">"Alice"</span>, <span class="string">"Bob"</span>];</span><br><span class="line">myArray[<span class="number">2</span>] = <span class="string">"Mallory"</span>; <span class="comment">// error!</span></span><br></pre></td></tr></tbody></table></figure>
<p>你不能设置<code>myArray[2]</code>，因为索引签名是只读的。</p>
<h1 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h1><h2 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h2><p>与C#或Java里接口的基本作用一样，TypeScript也能够用它来明确的强制一个类去符合某种契约。</p>
<figure class="highlight ts"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> ClockInterface {</span><br><span class="line">    currentTime: <span class="built_in">Date</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Clock <span class="keyword">implements</span> ClockInterface {</span><br><span class="line">    currentTime: <span class="built_in">Date</span>;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>) { }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>你也可以在接口中描述一个方法，在类里实现它，如同下面的<code>setTime</code>方法一样：</p>
<figure class="highlight ts"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> ClockInterface {</span><br><span class="line">    currentTime: <span class="built_in">Date</span>;</span><br><span class="line">    setTime(d: <span class="built_in">Date</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Clock <span class="keyword">implements</span> ClockInterface {</span><br><span class="line">    currentTime: <span class="built_in">Date</span>;</span><br><span class="line">    setTime(d: <span class="built_in">Date</span>) {</span><br><span class="line">        <span class="keyword">this</span>.currentTime = d;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>) { }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>接口描述了类的公共部分，而不是公共和私有两部分。 它不会帮你检查类是否具有某些私有成员。</p>
<blockquote>
<p>在Java中，如果多个类处理的目标是一样的，但是处理的方法方式不同，那么就定义一个接口，也就是一个标准，让他们的实现这个接口，各自实现自己具体的处理方法来处理那个目标。而在TypeScript中实现一个接口，更多是一种约束，一种规定</p>
</blockquote>
<h2 id="类静态部分与实例部分的区别"><a href="#类静态部分与实例部分的区别" class="headerlink" title="类静态部分与实例部分的区别"></a>类静态部分与实例部分的区别</h2><p>当你操作类和接口的时候，你要知道类是具有两个类型的：静态部分的类型和实例的类型。 你会注意到，当你用构造器签名去定义一个接口并试图定义一个类去实现这个接口时会得到一个错误：</p>
<figure class="highlight ts"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> ClockConstructor {</span><br><span class="line">    <span class="keyword">new</span> (hour: <span class="built_in">number</span>, minute: <span class="built_in">number</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Clock <span class="keyword">implements</span> ClockConstructor {</span><br><span class="line">    currentTime: <span class="built_in">Date</span>;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>) { }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这里因为当一个类实现了一个接口时，只对其实例部分进行类型检查。 constructor存在于类的静态部分，所以不在检查的范围内。</p>
<p>因此，我们应该直接操作类的静态部分。 看下面的例子，我们定义了两个接口， <code>ClockConstructor</code>为构造函数所用和<code>ClockInterface</code>为实例方法所用。 为了方便我们定义一个构造函数 <code>createClock</code>，它用传入的类型创建实例。</p>
<figure class="highlight ts"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> ClockConstructor {</span><br><span class="line">    <span class="keyword">new</span> (hour: <span class="built_in">number</span>, minute: <span class="built_in">number</span>): ClockInterface;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">interface</span> ClockInterface {</span><br><span class="line">    tick();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createClock</span>(<span class="params">ctor: ClockConstructor, hour: <span class="built_in">number</span>, minute: <span class="built_in">number</span></span>): <span class="title">ClockInterface</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ctor(hour, minute);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> DigitalClock <span class="keyword">implements</span> ClockInterface {</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>) { }</span><br><span class="line">    tick() {</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"beep beep"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">class</span> AnalogClock <span class="keyword">implements</span> ClockInterface {</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>) { }</span><br><span class="line">    tick() {</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"tick tock"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> digital = createClock(DigitalClock, <span class="number">12</span>, <span class="number">17</span>);</span><br><span class="line"><span class="keyword">let</span> analog = createClock(AnalogClock, <span class="number">7</span>, <span class="number">32</span>);</span><br></pre></td></tr></tbody></table></figure>
<p>因为<code>createClock</code>的第一个参数是<code>ClockConstructor</code>类型，在<code>createClock(AnalogClock, 7, 32)</code>里，会检查<code>AnalogClock</code>是否符合构造函数签名。</p>
<h1 id="继承接口"><a href="#继承接口" class="headerlink" title="继承接口"></a>继承接口</h1><p>和类一样，接口也可以相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。</p>
<figure class="highlight ts"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Shape {</span><br><span class="line">    color: <span class="built_in">string</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Square <span class="keyword">extends</span> Shape {</span><br><span class="line">    sideLength: <span class="built_in">number</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> square = &lt;Square&gt;{};</span><br><span class="line">square.color = <span class="string">"blue"</span>;</span><br><span class="line">square.sideLength = <span class="number">10</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>一个接口可以继承多个接口，创建出多个接口的合成接口。</p>
<figure class="highlight ts"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Shape {</span><br><span class="line">    color: <span class="built_in">string</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> PenStroke {</span><br><span class="line">    penWidth: <span class="built_in">number</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Square <span class="keyword">extends</span> Shape, PenStroke {</span><br><span class="line">    sideLength: <span class="built_in">number</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> square = &lt;Square&gt;{};</span><br><span class="line">square.color = <span class="string">"blue"</span>;</span><br><span class="line">square.sideLength = <span class="number">10</span>;</span><br><span class="line">square.penWidth = <span class="number">5.0</span>;</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>在Java中，是单一继承，多个实现。这里只是一个接口可以继承多个接口</p>
</blockquote>
<h1 id="混合类型"><a href="#混合类型" class="headerlink" title="混合类型"></a>混合类型</h1><p>先前我们提过，接口能够描述JavaScript里丰富的类型。 因为JavaScript其动态灵活的特点，有时你会希望一个对象可以同时具有上面提到的多种类型。</p>
<p>一个例子就是，一个对象可以同时做为函数和对象使用，并带有额外的属性。</p>
<figure class="highlight ts"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Counter {</span><br><span class="line">    (start: <span class="built_in">number</span>): <span class="built_in">string</span>;</span><br><span class="line">    interval: <span class="built_in">number</span>;</span><br><span class="line">    reset(): <span class="built_in">void</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCounter</span>(<span class="params"></span>): <span class="title">Counter</span> </span>{</span><br><span class="line">    <span class="keyword">let</span> counter = &lt;Counter&gt;<span class="function"><span class="keyword">function</span> (<span class="params">start: <span class="built_in">number</span></span>) </span>{ };</span><br><span class="line">    counter.interval = <span class="number">123</span>;</span><br><span class="line">    counter.reset = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{ };</span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = getCounter();</span><br><span class="line">c(<span class="number">10</span>);</span><br><span class="line">c.reset();</span><br><span class="line">c.interval = <span class="number">5.0</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>在使用JavaScript第三方库的时候，你可能需要像上面那样去完整地定义类型。</p>
<h1 id="接口继承类"><a href="#接口继承类" class="headerlink" title="接口继承类"></a>接口继承类</h1><p>当接口继承了一个类类型时，它会继承类的成员但不包括其实现。 就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。 接口同样会继承到类的private和protected成员。 这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现（implement）。</p>
<p>当你有一个庞大的继承结构时这很有用，但要指出的是你的代码只在子类拥有特定属性时起作用。 这个子类除了继承至基类外与基类没有任何关系。 例：</p>
<figure class="highlight ts"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Control {</span><br><span class="line">    <span class="keyword">private</span> state: <span class="built_in">any</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> SelectableControl <span class="keyword">extends</span> Control {</span><br><span class="line">    select(): <span class="built_in">void</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Button <span class="keyword">extends</span> Control <span class="keyword">implements</span> SelectableControl {</span><br><span class="line">    select() { }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> TextBox <span class="keyword">extends</span> Control {</span><br><span class="line">    select() { }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误：“Image”类型缺少“state”属性。</span></span><br><span class="line"><span class="keyword">class</span> Image <span class="keyword">implements</span> SelectableControl {</span><br><span class="line">    select() { }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Location {</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在上面的例子里，<code>SelectableControl</code>包含了<code>Control</code>的所有成员，包括私有成员<code>state</code>。 因为 <code>state</code>是私有成员，所以只能够是<code>Control</code>的子类们才能实现<code>SelectableControl</code>接口。 因为只有 <code>Control</code>的子类才能够拥有一个声明于<code>Control</code>的私有成员<code>state</code>，这对私有成员的兼容性是必需的。</p>
<p>在<code>Control</code>类内部，是允许通过<code>SelectableControl</code>的实例来访问私有成员<code>state</code>的。 实际上， <code>SelectableControl</code>接口和拥有<code>select</code>方法的<code>Control</code>类是一样的。 <code>Button</code>和<code>TextBox</code>类是<code>SelectableControl</code>的子类（因为它们都继承自<code>Control</code>并有<code>select</code>方法），但<code>Image</code>和<code>Location</code>类并不是这样的。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>typescript</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker_Getting_Started</title>
    <url>/posts/Docker_Getting_Started.html</url>
    <content><![CDATA[<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>环境 <code>win10</code>，已开启 <code>Hyper-V</code>后，成功安装 <code>Docker Desktop</code>。打开后可以看到一个命令：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">docker run -d -p 80:80 docker/getting-started</span><br></pre></td></tr></tbody></table></figure>
<p>在执行这个命令之前，先修改下 <code>docker</code> 中的镜像</p>
<figure class="highlight diff"><figcaption><span>地址：Settings/Docker Engine</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">{</span><br><span class="line">  "registry-mirrors": [</span><br><span class="line"><span class="addition">+    "https://registry.docker-cn.com"</span></span><br><span class="line">  ],</span><br><span class="line">  ....</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>或者使用阿里的docker镜像</p>
<a id="more"></a>
<p>之后再执行命令：</p>
<p><img src="/posts/./Docker_Getting_Started\getting-started.png" alt=""></p>
<p>成功后，访问 <code>localhost/tutorial</code>，在 <code>docker desktop</code> 中也可以看到刚刚获取的东西</p>
<p><img src="/posts/./Docker_Getting_Started\getting-started2.png" alt="image-20201214204505252"></p>
<p>对于刚刚运行的命令</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">docker run -d -p 80:80 docker/getting-started</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>-d</code> ：在后台中以隔离模式运行容器</li>
<li><code>-p 80:80</code> ：将主机<code>localhost</code>中 80 端口映射到容器的 80 端口</li>
<li><code>docker/getting-started</code>：使用到的镜像</li>
</ul>
<p>以上的命令也可以缩写成：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">docker run -dp 80:80 docker/getting-started</span><br></pre></td></tr></tbody></table></figure>
<h3 id="Docker-Dashboard"><a href="#Docker-Dashboard" class="headerlink" title="Docker Dashboard"></a>Docker Dashboard</h3><p>在继续的深入之前，想重点介绍 docker dashboard，它可以让你快速看到目前机器上运行了的容器。可以快速访问容器日志，容器中有命令解析器（即可以在容器中输入命令），更方便管控容器的生命周期（停止服务，删除等）</p>
<p><code>getting-started</code> 在一个随机命名的容器内。当然你也可以随意取名</p>
<p>先查看系统中目前的容器</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></tbody></table></figure>
<p>找到想要修改的容器，找到它的 <code>container id</code>，修改名称：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">docker rename container_id newname</span><br></pre></td></tr></tbody></table></figure>
<p>第一个参数可以是 <code>container id</code> 和 <code>name</code>。如果一个容器的name和另一个容器的id是一样的，会执行两次。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">docker ps</span><br><span class="line">CONTAINER ID NAMES</span><br><span class="line">41033a3d043a  hello</span><br><span class="line">41033a3d043b  41033a3d043a</span><br></pre></td></tr></tbody></table></figure>
<p><code>docker rename</code>第一个参数<code>&lt;my_container&gt;</code>，是先匹配<code>NAME</code>，再匹配<code>ID</code>的。也就是说下列语句会被正确执行两次，第一次会把<code>name</code>为<code>41033a3d043a</code>的容器改名，第二次会把<code>id</code>为<code>41033a3d043a</code>的容器改名。</p>
<h3 id="什么是容器（container）？"><a href="#什么是容器（container）？" class="headerlink" title="什么是容器（container）？"></a>什么是容器（container）？</h3><p>现在你已经运行了一个容器，什么是容器呢？简单来说，容器是你机器上的一个进程，可以把它想象成是一个箱子，与主机上的其他进程隔离。这种隔离的方式利用  内核（<code>kernel namespaces</code>）内核名称空间与 <code>cgroups</code>，这个功能已经在 Linux 存在了很长一段时间。Docker 致力与使这些功能更易于使用。</p>
<p>如果想知道如何从头开始创建容器，可以看下来自 Aqua Security 的 Liz Rice 的演讲，展示了使用 Go 从头开始创建一个容器。虽然这是一个简单容器，没有涉及到网络，文件系统映像等等。但是它可以让你深入了解这些是如何运作的。</p>
<ul>
<li>Youtube 地址：<a href="https://www.youtube-nocookie.com/embed/8fi7uSYlOdc" target="_blank" rel="noopener">https://www.youtube-nocookie.com/embed/8fi7uSYlOdc</a></li>
<li>BiliBili地址：<a href="https://www.bilibili.com/video/BV1Nh411d7NE" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1Nh411d7NE</a></li>
</ul>
<div style="position:relative; padding-bottom:75%; width:100%; height:0">
    <iframe src="//player.bilibili.com/player.html?bvid=BV1Nh411d7NE&amp;page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position:absolute; height: 100%; width: 100%;"></iframe>
</div>



<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Go&amp;Plan 9</title>
    <url>/posts/Go&amp;Plan%209.html</url>
    <content><![CDATA[<h1 id="Plan-9"><a href="#Plan-9" class="headerlink" title="Plan 9"></a>Plan 9</h1><p><img src="https://pic1.zhimg.com/80/9f8102da606acb83969812978cdd4538_hd.jpg" alt=""></p>
<h2 id="Plan-9是什么"><a href="#Plan-9是什么" class="headerlink" title="Plan 9是什么"></a>Plan 9是什么</h2><p>它是一个网络操作系统（大规模集群）或者说是一种概念，来自贝尔实验室，由<em>Ken Thompson</em>、<em>Dennis Ritchied</em>等大神开发。</p>
<a id="more"></a>
<p>是一个<code>Unix</code>系统，想真正的实现<strong>一切皆文件</strong>这个想法。Google中的绝大部分资料，从各种存储系统到RPC服务，都可以用类似的/gfs/…/bigtable/…的文件名方式在全部Google集群中的唯一寻址，很大部分存储系统统一使用FIle API系统访问。（<code>/proc</code>文件系统概念还有<code>UTF-8</code>）（<code>/net/tcp</code>文件系统）</p>
<p>这个可能是它的官网：<a href="http://9p.io/plan9/" target="_blank" rel="noopener">http://9p.io/plan9/</a></p>
<h2 id="Plan-9与Go"><a href="#Plan-9与Go" class="headerlink" title="Plan 9与Go"></a>Plan 9与Go</h2><p><code>Go</code>语言的实现使用到了<code>Plan 9</code>的汇编器，与<code>AT&amp;T</code>和<code>Intel</code>的汇编器不同，也不是<code>C</code>语言内嵌汇编的语法。了解<code>Go</code>的汇编是为了学习<code>Go</code>的实现细节</p>
<p>资料：</p>
<p><a href="https://zhuanlan.zhihu.com/p/56750445" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/56750445</a></p>
<p><a href="https://golang.google.cn/doc/asm" target="_blank" rel="noopener">https://golang.google.cn/doc/asm</a></p>
<p><a href="https://mp.weixin.qq.com/s/B577CdUkWCp_XgUc1VVvSQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/B577CdUkWCp_XgUc1VVvSQ</a></p>
<p><a href="http://doc.cat-v.org/plan_9/4th_edition/papers/asm" target="_blank" rel="noopener">http://doc.cat-v.org/plan_9/4th_edition/papers/asm</a></p>
<p>柴树杉的 Go语言高级编程</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>Go</tag>
        <tag>Plan 9</tag>
      </tags>
  </entry>
  <entry>
    <title>Go struct</title>
    <url>/posts/Go_10.html</url>
    <content><![CDATA[<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>Go 中的<code>struct</code>与 C 中的 <code>struct</code>非常相似，并且 Go 没有 class 。使用 <code>type&lt;Name&gt; struct{}</code>定义结构，名称遵循可见性规则。</p>
<ul>
<li>支持指向自身的指针类型成员</li>
<li>支持匿名结构，可用作成员或定义成员变量</li>
<li>匿名结构也可以用于<code>map</code>的值</li>
<li>可以使用字面值对结构进行初始化</li>
<li>运行直接通过指针来读写结构成员</li>
<li>相同类型的成员可进行直接拷贝赋值</li>
<li>支持<code>==</code>与<code>!=</code>比较运算符，但是不支持<code>&gt;</code>和<code>&lt;</code></li>
<li>支持匿名字段，本质上是定于了以某个类型名为名称的字段</li>
<li>嵌入结构作为匿名字段看起来像继承，但不是继承</li>
<li>可使用匿名字段指针</li>
</ul>
<a id="more"></a>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> {</span><br><span class="line">	name   <span class="keyword">string</span></span><br><span class="line">	age    <span class="keyword">int</span></span><br><span class="line">	mobile <span class="keyword">int</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	amy := person{<span class="string">"Amy"</span>, <span class="number">18</span>, <span class="number">112340259</span>}</span><br><span class="line">	fmt.Println(amy)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">{Amy 18 112340259}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p>类似像JavaScript中对象属性的操作</p>
<figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">func main() {</span><br><span class="line">	amy := person{"Amy", 18, 112340259}</span><br><span class="line"><span class="addition">+	amy.age = 22</span></span><br><span class="line">	fmt.Println(amy)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">{Amy 22 112340259}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="值拷贝"><a href="#值拷贝" class="headerlink" title="值拷贝"></a>值拷贝</h3><p>作为函数的参数时，是一个值拷贝，而不是引用类型</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">structTest1</span><span class="params">(a person)</span></span> {</span><br><span class="line">   a.age = <span class="number">30</span></span><br><span class="line">   fmt.Println(<span class="string">"struct test 1"</span>, a)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">   amy := person{<span class="string">"Amy"</span>, <span class="number">18</span>, <span class="number">112340259</span>}</span><br><span class="line">   amy.age = <span class="number">22</span></span><br><span class="line">   fmt.Println(amy)</span><br><span class="line">   structTest1(amy)</span><br><span class="line">   fmt.Println(<span class="string">"after:"</span>, amy)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">{Amy 22 112340259}</span><br><span class="line">struct test 1 {Amy 30 112340259}</span><br><span class="line">after: {Amy 22 112340259}</span><br></pre></td></tr></tbody></table></figure>
<p>可以发现<code>age</code>在函数执行后并没有发生改变。如果需要改变，需要传递指针(地址)</p>
<figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line"><span class="addition">+ func structTest1(a *person) {</span></span><br><span class="line"><span class="deletion">- func structTest1(a person) {</span></span><br><span class="line">	a.age = 30</span><br><span class="line">	fmt.Println("struct test 1", a)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">	amy := person{"Amy", 18, 112340259}</span><br><span class="line">	amy.age = 22</span><br><span class="line">	fmt.Println(amy)</span><br><span class="line"><span class="deletion">-	structTest1(amy)</span></span><br><span class="line"><span class="addition">+	structTest1(&amp;amy)</span></span><br><span class="line">	fmt.Println("after:", amy)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">{Amy 22 112340259}</span><br><span class="line">struct test 1 &amp;{Amy 30 112340259}</span><br><span class="line">after: {Amy 30 112340259}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="指向结构的指针"><a href="#指向结构的指针" class="headerlink" title="指向结构的指针"></a>指向结构的指针</h3><p>在初始化时，变成结构的指针，也可以达到上面的效果。</p>
<figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line"><span class="deletion">- amy := person{"Amy", 18, 112340259}</span></span><br><span class="line"><span class="addition">+ amy := &amp;person{"Amy", 18, 112340259}</span></span><br><span class="line"></span><br><span class="line">... 省略代码</span><br><span class="line"></span><br><span class="line"><span class="addition">+	structTest1(amy)</span></span><br><span class="line"><span class="deletion">-	structTest1(&amp;amy)</span></span><br></pre></td></tr></tbody></table></figure>
<p>在对一个结构进行初始化时，习惯性使用取地址符号<code>&amp;</code>，变量就变成指向某个结构的指针，方便在下面编码过程中特地去获取地址。且也可以直接对结构中的属性直接进行操作</p>
<h3 id="匿名结构"><a href="#匿名结构" class="headerlink" title="匿名结构"></a>匿名结构</h3><p>没定义结构的名称，临时声明了一个结构，并对字面值进行了初始化</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">dog := &amp;<span class="keyword">struct</span> {</span><br><span class="line">	color <span class="keyword">string</span></span><br><span class="line">	tail  <span class="keyword">string</span></span><br><span class="line">}{</span><br><span class="line">	<span class="string">"white"</span>,</span><br><span class="line">	<span class="string">"long"</span>,</span><br><span class="line">}</span><br><span class="line">fmt.Println(dog)</span><br></pre></td></tr></tbody></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&amp;{white long}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="结构体中"><a href="#结构体中" class="headerlink" title="结构体中"></a>结构体中</h4><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> {</span><br><span class="line">   name   <span class="keyword">string</span></span><br><span class="line">   age    <span class="keyword">int</span></span><br><span class="line">   mobile <span class="keyword">struct</span> {</span><br><span class="line">      phone, address <span class="keyword">string</span></span><br><span class="line">   }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	a := &amp;person{name: <span class="string">"amy"</span>, age: <span class="number">18</span>}</span><br><span class="line">	a.mobile.phone = <span class="string">"123"</span></span><br><span class="line">	a.mobile.address = <span class="string">"china"</span></span><br><span class="line">	fmt.Println(a)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&amp;{amy 18 {123 china}}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="匿名字段"><a href="#匿名字段" class="headerlink" title="匿名字段"></a>匿名字段</h3><p>在结构体中未声明属性名</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> pet <span class="keyword">struct</span> {</span><br><span class="line">	<span class="keyword">string</span></span><br><span class="line">	<span class="keyword">int</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	a := &amp;pet{<span class="string">"dog"</span>, <span class="number">2</span>}</span><br><span class="line">	fmt.Println(a)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&amp;{dog 2}</span><br></pre></td></tr></tbody></table></figure>
<p>如果此时交换初始化参数的位置，会发生错误</p>
<figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line"><span class="deletion">- a := &amp;pet{"dog", 2}</span></span><br><span class="line"><span class="addition">+ a := &amp;pet{2, "dog"}</span></span><br></pre></td></tr></tbody></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"># command-line-arguments</span><br><span class="line">.....: cannot use 2 (type untyped int) as type string in field value</span><br><span class="line">.....: cannot use "dog" (type untyped string) as type int in field value</span><br></pre></td></tr></tbody></table></figure>
<h3 id="类型比较操作"><a href="#类型比较操作" class="headerlink" title="类型比较操作"></a>类型比较操作</h3><p>同类型之间的可以进行比较，作<code>==</code>和<code>!=</code>，不能作<code>&gt;</code>或者<code>&lt;</code></p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">a := pet{name: <span class="string">"Amy"</span>, age: <span class="number">18</span>}</span><br><span class="line">b := pet{name: <span class="string">"Amy"</span>, age: <span class="number">18</span>}</span><br><span class="line">fmt.Println(a == b)</span><br></pre></td></tr></tbody></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">true</span><br></pre></td></tr></tbody></table></figure>
<p>如果内容一致，但是类型不一样</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">a := pet{name: <span class="string">"Amy"</span>, age: <span class="number">18</span>}</span><br><span class="line">b := dog{name: <span class="string">"Amy"</span>, age: <span class="number">18</span>}</span><br><span class="line">fmt.Println(a == b)</span><br></pre></td></tr></tbody></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"># command-line-arguments</span><br><span class="line">.....: invalid operation: a == b (mismatched types pet and dog)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="嵌入struct"><a href="#嵌入struct" class="headerlink" title="嵌入struct"></a>嵌入struct</h3><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> human <span class="keyword">struct</span> {</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	age  <span class="keyword">int</span></span><br><span class="line">	sex  <span class="keyword">int</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">type</span> teacher <span class="keyword">struct</span> {</span><br><span class="line">	human</span><br><span class="line">	class <span class="keyword">string</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> {</span><br><span class="line">	human</span><br><span class="line">	classRoom <span class="keyword">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	a := teacher{human: human{<span class="string">"A"</span>, <span class="number">12</span>, <span class="number">1</span>}, class: <span class="string">"english"</span>}</span><br><span class="line">	b := student{human{<span class="string">"a"</span>, <span class="number">2</span>, <span class="number">0</span>}, <span class="string">"2002"</span>}</span><br><span class="line">    b.name = <span class="string">"aa"</span></span><br><span class="line">	fmt.Println(a, b)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">{{A 12 1} english} {{aa 2 0} 2002}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>如果匿名字段和外层结构有同名字段，应该如何进行操作</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> basePo <span class="keyword">struct</span> {</span><br><span class="line">	id <span class="keyword">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> bizBasePo <span class="keyword">struct</span> {</span><br><span class="line">	basePo</span><br><span class="line">	id <span class="keyword">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	bill := bizBasePo{id: <span class="string">"1"</span>, basePo: basePo{id: <span class="string">"2"</span>}}</span><br><span class="line">	fmt.Println(bill.id, bill.basePo.id)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">1 2</span><br></pre></td></tr></tbody></table></figure>
<p><code>bizBasePo</code>与<code>basePo</code>存在同名字段</p>
<figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">bill := bizBasePo{id: "1", basePo: basePo{id: "2"}}</span><br><span class="line"><span class="addition">+ bill.name = "3"</span></span><br><span class="line">fmt.Println(bill.id, bill.basePo.id)</span><br></pre></td></tr></tbody></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">3 2</span><br></pre></td></tr></tbody></table></figure>
<p>如果直接改成这样</p>
<figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">type basePo struct {</span><br><span class="line">	id string</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">type bizBasePo struct {</span><br><span class="line">	basePo</span><br><span class="line"><span class="deletion">-	id string</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">2 2</span><br></pre></td></tr></tbody></table></figure>
<p>如果是多个同名</p>
<figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">type basePo struct {</span><br><span class="line">	id string</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="addition">+ type flowPo struct {</span></span><br><span class="line"><span class="addition">+	 id string</span></span><br><span class="line"><span class="addition">+ }</span></span><br><span class="line"></span><br><span class="line">type bizBasePo struct {</span><br><span class="line">	basePo</span><br><span class="line"><span class="addition">+	flowPo</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"><span class="addition">+	bill := bizBasePo{basePo: basePo{id: "2"}, flowPo: flowPo{id: "5"}}</span></span><br><span class="line">	fmt.Println(bill.id, bill.basePo.id)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"># command-line-arguments</span><br><span class="line">...: ambiguous selector bill.id</span><br></pre></td></tr></tbody></table></figure>
<p>编译错误，此时使用那个嵌入体中的字段</p>
<p>可以改成这样</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> basePo <span class="keyword">struct</span> {</span><br><span class="line">	id <span class="keyword">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> flowPo <span class="keyword">struct</span> {</span><br><span class="line">	basePo</span><br><span class="line">	id <span class="keyword">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> bizBasePo <span class="keyword">struct</span> {</span><br><span class="line">	flowPo</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	bill := bizBasePo{flowPo: flowPo{id: <span class="string">"5"</span>, basePo: basePo{id: <span class="string">"2"</span>}}}</span><br><span class="line">	fmt.Println(bill.id, bill.flowPo.id, bill.flowPo.basePo.id)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go interface</title>
    <url>/posts/Go_12.html</url>
    <content><![CDATA[<h2 id="接口-interface"><a href="#接口-interface" class="headerlink" title="接口 interface"></a>接口 interface</h2><p>接口是一个或多个方法签名的集合，只要某个类型拥有该接口的所有方法签名，即算实现该接口，无需显示声明了实现了哪个接口，这称为 Structural Typing</p>
<p>接口只有方法声明，没有实现，没有数据类型</p>
<p>接口可以匿名嵌入其他接口，或嵌入结构中</p>
<p>将对象赋值给接口时，会发生拷贝，而接口内部存储的是指向这个复制品的指针，即无法修改复制品的状态 ，也无法获取指针</p>
<p>只有当接口存储的类型和对象都为 nil 时，接口才等于 nil</p>
<p>接口调用不会做 receiver 的自动转换</p>
<p>接口同样支持匿名字段方法</p>
<p>接口可实现类型 OOP 中的多态</p>
<p>空接口可以作为任何类型数据的容器</p>
<a id="more"></a>
<h3 id="接口定义与基本操作"><a href="#接口定义与基本操作" class="headerlink" title="接口定义与基本操作"></a>接口定义与基本操作</h3><p>接口是一个或多个方法签名的集合，只要<strong>某个类型</strong>拥有该接口的<strong>所有方法</strong>签名，即算实现该接口，无需显示声明了实现了哪个接口，这称为 <em>Structural Typing</em></p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> USB <span class="keyword">interface</span> {</span><br><span class="line">	Name() <span class="keyword">string</span></span><br><span class="line">	Connect()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PhoneConnector <span class="keyword">struct</span> {</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pc PhoneConnector)</span> <span class="title">Name</span><span class="params">()</span> <span class="title">string</span></span> {</span><br><span class="line">	<span class="keyword">return</span> pc.name</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pc PhoneConnector)</span> <span class="title">Connect</span><span class="params">()</span></span> {</span><br><span class="line">	fmt.Println(<span class="string">"Connect:"</span>, pc.name)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="keyword">var</span> a USB</span><br><span class="line">	a = PhoneConnector{<span class="string">"huawei"</span>}</span><br><span class="line">	a.Connect()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Connect: huawei</span><br></pre></td></tr></tbody></table></figure>
<p><code>PhoneConnector</code>拥有<code>USB</code>接口所有的<strong>方法</strong>，即实现了该接口</p>
<p>符合该interface的方法</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Disconnect</span><span class="params">(usb USB)</span></span> {</span><br><span class="line">	fmt.Println(<span class="string">"Disconnected."</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    ... 省略</span><br><span class="line">    Disconnect(a)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Disconnected.</span><br></pre></td></tr></tbody></table></figure>
<h3 id="嵌入接口"><a href="#嵌入接口" class="headerlink" title="嵌入接口"></a>嵌入接口</h3><p>一个接口中包含另一个接口</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> USB <span class="keyword">interface</span> {</span><br><span class="line">   Name() <span class="keyword">string</span></span><br><span class="line">   Connector</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Connector <span class="keyword">interface</span> {</span><br><span class="line">   Connect()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p><code>interface.(struct)</code></p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Disconnect</span><span class="params">(usb USB)</span></span> {</span><br><span class="line">	<span class="keyword">if</span> pc, ok := usb.(PhoneConnector); ok {</span><br><span class="line">		fmt.Println(<span class="string">"DisConnected."</span>, pc.name)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	}</span><br><span class="line">	fmt.Println(<span class="string">"Unknown dec."</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="空接口与-type-switch"><a href="#空接口与-type-switch" class="headerlink" title="空接口与 type switch"></a>空接口与 type switch</h3><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 空接口</span></span><br><span class="line"><span class="keyword">type</span> empty <span class="keyword">interface</span> {}</span><br></pre></td></tr></tbody></table></figure>
<p>意味着在Go中所有的类型都实现空接口</p>
<figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line"><span class="deletion">- func Disconnect(usb USB) {</span></span><br><span class="line"><span class="addition">+ func Disconnect(usb interface{}) {</span></span><br></pre></td></tr></tbody></table></figure>
<p>空接口以为所有的类型都是可以进入，如果要判断某一类型时，使用<code>type switch</code>进行处理：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Disconnect</span><span class="params">(usb <span class="keyword">interface</span>{})</span></span> {</span><br><span class="line">	<span class="keyword">switch</span> v := usb.(<span class="keyword">type</span>) {</span><br><span class="line">	<span class="keyword">case</span> PhoneConnector:</span><br><span class="line">		fmt.Println(<span class="string">"Disconnected"</span>, v.name)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Println(<span class="string">"Unknown dec."</span>)</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="接口转换"><a href="#接口转换" class="headerlink" title="接口转换"></a>接口转换</h3><p>由基础往下进行转换</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">pc := PhoneConnector{<span class="string">"phone"</span>}</span><br><span class="line"><span class="keyword">var</span> a Connector</span><br><span class="line">a = Connector(pc)</span><br><span class="line">a.Connect()</span><br></pre></td></tr></tbody></table></figure>
<h3 id="接口使用注意事项"><a href="#接口使用注意事项" class="headerlink" title="接口使用注意事项"></a>接口使用注意事项</h3><p>将对象赋值给接口时，会发生拷贝，而接口内部存储的是指向这个复制品的指针，即无法修改复制品的状态 ，也无法获取指针</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	 pc := PhoneConnector{<span class="string">"phone"</span>}</span><br><span class="line">	 <span class="keyword">var</span> a Connector</span><br><span class="line">	 a = Connector(pc)</span><br><span class="line">	 a.Connect()</span><br><span class="line"></span><br><span class="line">	 pc.name = <span class="string">"pc"</span></span><br><span class="line">	 a.Connect()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Connect: phone</span><br><span class="line">Connect: phone</span><br></pre></td></tr></tbody></table></figure>
<p>只有值拷贝</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go method</title>
    <url>/posts/Go_11.html</url>
    <content><![CDATA[<h2 id="方法-Method"><a href="#方法-Method" class="headerlink" title="方法 Method"></a>方法 Method</h2><p>Go 中虽然没有<code>class</code>，但依旧有<code>method</code>，通过显示说明<code>receiver</code>来实现与某个类型的组合，只能为同一个包中的类型定义方法，<code>receiver</code>可以是类型的值或指针。</p>
<p><code>method</code>不存在方法重载，可以是使用值或指针来调节方法，编译器会自动完成转换，从某种意义上来说，方法是函数的语法糖，因为<code>receiver</code>其实就是方法所接收的第一个参数（Method Value vs Method Expression）</p>
<p>如果外部结构和嵌入结构存在同名方法，则优先调用外部结构的方法，类型别名不会拥有底层类型所附带的方法。</p>
<p>方法可以待用结构中的非公开字段</p>
<a id="more"></a>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> SysUser <span class="keyword">struct</span> {</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(user SysUser)</span> <span class="title">ToString</span><span class="params">()</span></span> {</span><br><span class="line">	user.name = <span class="string">"123"</span></span><br><span class="line">	fmt.Println(user.name)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	user := SysUser{name: <span class="string">"1"</span>}</span><br><span class="line">	user.ToString()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">123</span><br></pre></td></tr></tbody></table></figure>
<p>其中<code>ToString</code>接收体是<code>SysUser</code></p>
<h3 id="不存在重载，通过类型绑定区分"><a href="#不存在重载，通过类型绑定区分" class="headerlink" title="不存在重载，通过类型绑定区分"></a>不存在重载，通过类型绑定区分</h3><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> SysUser <span class="keyword">struct</span> {</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SysOrg <span class="keyword">struct</span> {</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(user SysUser)</span> <span class="title">ToString</span><span class="params">()</span></span> {</span><br><span class="line">	user.name = <span class="string">"123"</span></span><br><span class="line">	fmt.Println(user.name)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(org SysOrg)</span> <span class="title">ToString</span><span class="params">()</span></span> {</span><br><span class="line">	org.name = <span class="string">"321"</span></span><br><span class="line">	fmt.Println(org.name)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	user := SysUser{name: <span class="string">"1"</span>}</span><br><span class="line">	user.ToString()</span><br><span class="line"></span><br><span class="line">	org := SysOrg{name: <span class="string">"2"</span>}</span><br><span class="line">	org.ToString()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">123</span><br><span class="line">321</span><br></pre></td></tr></tbody></table></figure>
<p>在这里，<code>ToString</code>分别绑定了<code>SysUser</code>和<code>SysOrg</code>，区分开了2种。</p>
<p>以下这种是不行的，以下函数针对同一个类型，区分不出来用户使用那一个。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(user SysUser)</span> <span class="title">ToString</span><span class="params">()</span></span> {</span><br><span class="line">	user.name = <span class="string">"123"</span></span><br><span class="line">	fmt.Println(user.name)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(user SysUser)</span> <span class="title">ToString</span><span class="params">(i <span class="keyword">int</span>)</span></span> {</span><br><span class="line">	user.name = i</span><br><span class="line">	fmt.Println(user.name)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>编译错误：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"># command-line-arguments</span><br><span class="line">: method redeclared: SysUser.ToString</span><br><span class="line">	method(SysUser) func()</span><br><span class="line">	method(SysUser) func(int)</span><br><span class="line">: SysUser.ToString redeclared in this block</span><br><span class="line">	previous declaration at .....</span><br><span class="line">.....: cannot use i (type int) as type string in assignment</span><br></pre></td></tr></tbody></table></figure>
<h3 id="可以是值或指针"><a href="#可以是值或指针" class="headerlink" title="可以是值或指针"></a>可以是值或指针</h3><p>如果是值类型，只是拷贝值，进行值传递。如果是指针类型，最终会影响到地址对应的值</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(user *SysUser)</span> <span class="title">ToString</span><span class="params">()</span></span> {</span><br><span class="line">	user.name = <span class="string">"123"</span></span><br><span class="line">	fmt.Println(user.name)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(org SysOrg)</span> <span class="title">ToString</span><span class="params">()</span></span> {</span><br><span class="line">	org.name = <span class="string">"321"</span></span><br><span class="line">	fmt.Println(org.name)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	user := SysUser{name: <span class="string">"1"</span>}</span><br><span class="line">	user.ToString()</span><br><span class="line">	fmt.Println(user)</span><br><span class="line"></span><br><span class="line">	org := SysOrg{name: <span class="string">"2"</span>}</span><br><span class="line">	org.ToString()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">123</span><br><span class="line">{123}</span><br><span class="line">321</span><br></pre></td></tr></tbody></table></figure>
<p>可以看到值发生了改变</p>
<h3 id="底层类型"><a href="#底层类型" class="headerlink" title="底层类型"></a>底层类型</h3><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> TZ <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *TZ)</span> <span class="title">Print</span><span class="params">()</span></span> {</span><br><span class="line">	fmt.Println(<span class="string">"TZ"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="keyword">var</span> a TZ</span><br><span class="line">	a.Print()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">TZ</span><br></pre></td></tr></tbody></table></figure>
<p>底层类型就可以自由加入方法的绑定</p>
<h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><h4 id="Method-Value"><a href="#Method-Value" class="headerlink" title="Method Value"></a>Method Value</h4><p>通过值进行调用</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a TZ</span><br><span class="line">a.Print()</span><br></pre></td></tr></tbody></table></figure>
<h4 id="Method-Expression"><a href="#Method-Expression" class="headerlink" title="Method Expression"></a>Method Expression</h4><p>通过一种类型进行调用</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">(*TZ).Print(&amp;a)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="方法访问权限与字段"><a href="#方法访问权限与字段" class="headerlink" title="方法访问权限与字段"></a>方法访问权限与字段</h3><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span>{</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	Age  <span class="keyword">int</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在同一个包内就可以进行访问，修改。当超出包的范围后，只有首字母大写字段暴露出去。</p>
<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>声明一个底层类型为int的类型，并实现调用方法递增到100</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *TZ)</span> <span class="title">Increase</span><span class="params">(num <span class="keyword">int</span>)</span></span> {</span><br><span class="line">	*a += TZ(num)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="keyword">var</span> a TZ</span><br><span class="line">	a.Increase(<span class="number">100</span>)</span><br><span class="line">	fmt.Print(a)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">100</span><br></pre></td></tr></tbody></table></figure>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go reflection</title>
    <url>/posts/Go_13.html</url>
    <content><![CDATA[<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>反射可以提高程序的灵活性，使得 interface() 有更大的发挥余地，反射使用 TypeOf 和 ValueOf 函数从接口中获取目标对象信息，将匿名字段作为独立字段。</p>
<p>修改对象状态的前提是 interface.data 是 settable , 即 pointer-interface</p>
<p>通过反射可以动态调用方法</p>
<a id="more"></a>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> {</span><br><span class="line">	Id   <span class="keyword">int</span></span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Age  <span class="keyword">int</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u User)</span> <span class="title">Hello</span><span class="params">()</span></span> {</span><br><span class="line">	fmt.Println(<span class="string">"Hello,"</span>, u.Name)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Info</span><span class="params">(o <span class="keyword">interface</span>{})</span></span> {</span><br><span class="line">	t := reflect.TypeOf(o)</span><br><span class="line">	fmt.Println(<span class="string">"Type:"</span>, t.Name())</span><br><span class="line"></span><br><span class="line">	v := reflect.ValueOf(o)</span><br><span class="line">	fmt.Println(<span class="string">"Fields"</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; t.NumField(); i++ {</span><br><span class="line">		f := t.Field(i)</span><br><span class="line">		val := v.Field(i).Interface()</span><br><span class="line">		fmt.Printf(<span class="string">"%6s: %v = %v"</span>, f.Name, f.Type, val)</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; t.NumMethod(); i++ {</span><br><span class="line">		m := t.Method(i)</span><br><span class="line">		fmt.Printf(<span class="string">"%6s: %v\n"</span>, m.Name, m.Type)</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	u := User{<span class="number">1</span>, <span class="string">"OK"</span>, <span class="number">12</span>}</span><br><span class="line">	Info(u)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Type: User</span><br><span class="line">Fields</span><br><span class="line">    Id: int = 1  Name: string = OK   Age: int = 12 Hello: func(main.User)</span><br></pre></td></tr></tbody></table></figure>
<p>如果传递是地址</p>
<figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line"><span class="deletion">- Info(u)</span></span><br><span class="line"><span class="addition">+ Info(&amp;u)</span></span><br></pre></td></tr></tbody></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">panic: reflect: NumField of non-struct type *main.User</span><br><span class="line">goroutine 1 [running]:</span><br><span class="line">reflect.(*rtype).NumField(0x10bcfa0, 0xc0000d2008)</span><br></pre></td></tr></tbody></table></figure>
<p>加入判断</p>
<figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">func Info(o interface{}) {</span><br><span class="line">	t := reflect.TypeOf(o)</span><br><span class="line">	fmt.Println("Type:", t.Name())</span><br><span class="line"></span><br><span class="line"><span class="addition">+	if k := t.Kind(); k != reflect.Struct{</span></span><br><span class="line"><span class="addition">+		fmt.Printf("传递参数不匹配")</span></span><br><span class="line"><span class="addition">+		return </span></span><br><span class="line"><span class="addition">+	}</span></span><br><span class="line">	.....	</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="匿名"><a href="#匿名" class="headerlink" title="匿名"></a>匿名</h3><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> {</span><br><span class="line">	Id   <span class="keyword">int</span></span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Age  <span class="keyword">int</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Manager <span class="keyword">struct</span> {</span><br><span class="line">	User</span><br><span class="line">	title <span class="keyword">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	m := Manager{User{<span class="number">1</span>, <span class="string">"OK"</span>, <span class="number">12</span>}, <span class="string">"123"</span>}</span><br><span class="line">	t := reflect.TypeOf(m)</span><br><span class="line">	fmt.Printf(<span class="string">"%#v\n"</span>, t.Field(<span class="number">1</span>))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>取匿名属性中的字段</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func main() {</span><br><span class="line">	m := Manager{User{1, "OK", 12}, "123"}</span><br><span class="line">	t := reflect.TypeOf(m)</span><br><span class="line">	fmt.Printf("%#v\n", t.FieldByIndex([]int{0, 0}))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="settable"><a href="#settable" class="headerlink" title="settable"></a>settable</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">x := 123</span><br><span class="line">v := reflect.ValueOf(&amp;x)</span><br><span class="line">v.Elem().SetInt(999)</span><br><span class="line">fmt.Println(x)</span><br></pre></td></tr></tbody></table></figure>
<p>通过反射修改属性值</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Set</span><span class="params">(o <span class="keyword">interface</span>{})</span></span> {</span><br><span class="line">	v := reflect.ValueOf(o)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> v.Kind() == reflect.Ptr &amp;&amp; !v.Elem().CanSet() {</span><br><span class="line">		fmt.Println(<span class="string">"error"</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	v = v.Elem()</span><br><span class="line">	<span class="keyword">if</span> f := v.FieldByName(<span class="string">"Name"</span>); f.Kind() == reflect.String {</span><br><span class="line">		f.SetString(<span class="string">"New Name"</span>)</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	u := User{<span class="number">1</span>, <span class="string">"OK"</span>, <span class="number">12</span>}</span><br><span class="line">	fmt.Println(u)</span><br><span class="line">	Set(&amp;u)</span><br><span class="line">	fmt.Println(u)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">{1 OK 12}</span><br><span class="line">{1 New Name 12}</span><br></pre></td></tr></tbody></table></figure>
<p>判断是否有该属性</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">if !f.IsValid() {</span><br><span class="line">    fmt.Println("not fund")</span><br><span class="line">    return</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>反射调用方法</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u User)</span> <span class="title">HelloSomeone</span><span class="params">(name <span class="keyword">string</span>)</span></span> {</span><br><span class="line">	fmt.Println(<span class="string">"Hello"</span>, name, <span class="string">", my name is "</span>, u.Name)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	u := User{<span class="number">1</span>, <span class="string">"OK"</span>, <span class="number">12</span>}</span><br><span class="line">	u.HelloSomeone(<span class="string">"Jack"</span>)</span><br><span class="line"></span><br><span class="line">	v := reflect.ValueOf(u)</span><br><span class="line">	mv := v.MethodByName(<span class="string">"HelloSomeone"</span>)</span><br><span class="line">	args := []reflect.Value{reflect.ValueOf(<span class="string">"Bob"</span>)}</span><br><span class="line">	mv.Call(args)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go cibcyrrency	</title>
    <url>/posts/Go_14.html</url>
    <content><![CDATA[<h2 id="并发concurrency"><a href="#并发concurrency" class="headerlink" title="并发concurrency"></a>并发concurrency</h2><p>gorountine </p>
<p>切换时间来实现“同时”运行，在并行则是利用多核实现多线程的运行，通过通信共享内存</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Go</span><span class="params">()</span></span>{</span><br><span class="line">	fmt.Println(<span class="string">"Go go!"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="keyword">go</span> Go()</span><br><span class="line">	time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<a id="more"></a>
<h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><p>channel 是 goroutine 沟通的桥梁，大都是阻塞同步的，通过 make 创建，close 关闭，channel 是引用类型，使用 for range 来迭代不断操作 channel ，可设置单向或双向通道，缓存大小，在未被填满之前不会发生阻塞</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>{</span><br><span class="line">		fmt.Println(<span class="string">"123"</span>)</span><br><span class="line">		c &lt;- <span class="literal">true</span></span><br><span class="line">	}()</span><br><span class="line">	&lt;- c </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="for-range"><a href="#for-range" class="headerlink" title="for range"></a>for range</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func main() {</span><br><span class="line">	c := make(chan bool)</span><br><span class="line">	go func() {</span><br><span class="line">		fmt.Println("123")</span><br><span class="line">		c &lt;- true</span><br><span class="line">		close(c)</span><br><span class="line">	}()</span><br><span class="line">	for v := range c {</span><br><span class="line">		fmt.Println(v)</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>缓存</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">1</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>有缓存时同步阻塞的，无缓是异步的</p>
<h4 id="多核运行"><a href="#多核运行" class="headerlink" title="多核运行"></a>多核运行</h4><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Go</span><span class="params">(c <span class="keyword">chan</span> <span class="keyword">bool</span>, index <span class="keyword">int</span>)</span></span> {</span><br><span class="line">	a := <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ {</span><br><span class="line">		a += i</span><br><span class="line">	}</span><br><span class="line">	fmt.Println(index, a)</span><br><span class="line">	c &lt;- <span class="literal">true</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line"></span><br><span class="line">	runtime.GOMAXPROCS(runtime.NumCPU())</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ {</span><br><span class="line">		<span class="keyword">go</span> Go(c, i)</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span> ; i  &lt; <span class="number">10</span> ; i++ {</span><br><span class="line">		&lt;- c</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="同步-sync-WaitGroup"><a href="#同步-sync-WaitGroup" class="headerlink" title="同步 sync.WaitGroup"></a>同步 sync.WaitGroup</h4><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Go</span><span class="params">(wg *sync.WaitGroup, index <span class="keyword">int</span>)</span></span> {</span><br><span class="line">	a := <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ {</span><br><span class="line">		a += i</span><br><span class="line">	}</span><br><span class="line">	fmt.Println(index, a)</span><br><span class="line">	wg.Done()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line"></span><br><span class="line">	runtime.GOMAXPROCS(runtime.NumCPU())</span><br><span class="line">	wg := sync.WaitGroup{}</span><br><span class="line">	wg.Add(<span class="number">10</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ {</span><br><span class="line">		<span class="keyword">go</span> Go(&amp;wg, i)</span><br><span class="line">	}</span><br><span class="line">	wg.Wait()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h3><p>可处理一个或多个 channel 的发生与接收，同时有多个可用的 channel 时按随机顺序处理，可用空的select来阻塞 main 函数，可设置超时 </p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	c1, c2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>), <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">	o := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">		<span class="keyword">for</span> {</span><br><span class="line">			<span class="keyword">select</span> {</span><br><span class="line">			<span class="keyword">case</span> v, ok := &lt;-c1:</span><br><span class="line">				<span class="keyword">if</span> !ok {</span><br><span class="line">					o &lt;- <span class="literal">true</span></span><br><span class="line">					<span class="keyword">break</span></span><br><span class="line">				}</span><br><span class="line">				fmt.Println(<span class="string">"c1"</span>, v)</span><br><span class="line">			<span class="keyword">case</span> v, ok := &lt;-c2:</span><br><span class="line">				<span class="keyword">if</span> !ok {</span><br><span class="line">					o &lt;- <span class="literal">true</span></span><br><span class="line">					<span class="keyword">break</span></span><br><span class="line">				}</span><br><span class="line">				fmt.Println(<span class="string">"c2"</span>, v)</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}()</span><br><span class="line"></span><br><span class="line">	c1 &lt;- <span class="number">1</span></span><br><span class="line">	c2 &lt;- <span class="string">"hi"</span></span><br><span class="line"></span><br><span class="line">	c1 &lt;- <span class="number">3</span></span><br><span class="line">	c2 &lt;- <span class="string">"hello"</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">close</span>(c1)</span><br><span class="line">	<span class="built_in">close</span>(c2)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="互相发送"><a href="#互相发送" class="headerlink" title="互相发送"></a>互相发送</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func Pingpong() {</span><br><span class="line">	i := 0</span><br><span class="line">	for {</span><br><span class="line">		fmt.Println(&lt;-c)</span><br><span class="line">		c &lt;- fmt.Sprintf("From Pingpong: Hi, #%d", i)</span><br><span class="line">		i++</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">	c = make(chan string)</span><br><span class="line">	go Pingpong()</span><br><span class="line">	for i := 0; i &lt; 10; i++ {</span><br><span class="line">		c &lt;- fmt.Sprintf("From main: Hello, #%d", i)</span><br><span class="line">		fmt.Println(&lt;-c)</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 安装配置与Demo</title>
    <url>/posts/Go_1.html</url>
    <content><![CDATA[<h2 id="什么是Go"><a href="#什么是Go" class="headerlink" title="什么是Go ?"></a>什么是Go ?</h2><p>​        <code>Go</code>是一门 <strong>并发支持</strong>、<strong>垃圾回收</strong>的<em>编译型系统编程语言</em>，旨在创造一门具有静态编译语言的高性能和动态语言的高效开发之间拥有良好平衡点的一门编程语言。</p>
<a id="more"></a>
<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p>​        主要是为了处理高并发和异步的场景，并简化代码，提高开发效率，提高项目运行时的稳定性。像是一些云产品处理高峰时候的并发请求，或者是一些桌面程序。<code>Go</code>的杀手级应用是<code>Docker</code>，其他是<code>PaaS</code>类型的项目，或是消息缓存中间件，日志收集等。可以看下这个知乎上面，这个回答：<a href="https://www.zhihu.com/question/296426314" target="_blank" rel="noopener">https://www.zhihu.com/question/296426314</a></p>
<h3 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h3><ul>
<li><strong>类型安全</strong>和<strong>内存安全</strong></li>
<li>以非常直观和极低代价的方案实现<strong>高并发</strong></li>
<li>高效的<strong>垃圾回收</strong>机制</li>
<li>快速编译（同时解决C语言中头文件太多的问题）</li>
<li>为多核计算机提供性能提升方案</li>
<li>UTF-8 编码支持</li>
</ul>
<h3 id="安装时的坑"><a href="#安装时的坑" class="headerlink" title="安装时的坑"></a>安装时的坑</h3><p>当前环境为<code>win10</code>，安装文件地址为：<a href="https://golang.org/dl/" target="_blank" rel="noopener">https://golang.org/dl/</a></p>
<p>下载<code>msi</code>文件就可以了，执行它并按照安装的指导进行安装，会为我们在<code>PATH</code>配置好环境，并在用户系统变量中配置<code>GOPATH</code>，这个变量需要作修改。还有一个<code>GOROOT</code>变量指向我们的<code>Go SDK</code>路径（即安装<code>Go</code>的地址）。安装后，检验下：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 查看安装的版本</span></span><br><span class="line">go version</span><br><span class="line"><span class="comment"># 查看关于go的环境变量</span></span><br><span class="line">go env</span><br></pre></td></tr></tbody></table></figure>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ul>
<li><p><code>go get</code> ： 获取远程包，需要git或hg环境</p>
</li>
<li><p><code>go run</code> ： 直接允许程序</p>
</li>
<li><p><code>go build</code> : 测试编译，检查是否有编译错误</p>
</li>
<li><p><code>go fmt</code> : 格式化源码</p>
</li>
<li><p><code>go install</code> : 编译包文件并编译整个程序</p>
</li>
<li><p><code>go test</code> : 运行测试文件</p>
</li>
<li><p><code>go doc</code> : 查看包文档</p>
</li>
</ul>
<p>在使用<code>go get</code>之前，可以修改下<code>go proxy</code>的地址<br></p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> GOPROXY = <span class="string">"https://goproxy.io,direct"</span></span><br></pre></td></tr></tbody></table></figure><p></p>
<h3 id="GOPATH的作用"><a href="#GOPATH的作用" class="headerlink" title="GOPATH的作用"></a>GOPATH的作用</h3><p>在配置<code>GO</code>环境时，除了<code>GOROOT</code>与<code>PATH</code>外，还需要在用户变量中修改<code>GOPATH</code>的值，这里指向工作空间的地址。在该工作空间中创建项目才可以运行，为什么会这样呢？</p>
<p><code>GOPATH</code> 工作空间是一个目录层次结构，其根目录包含三个子目录（这些需要自己手动创建）：</p>
<ul>
<li><code>src</code>：包含 <code>Go</code> 源文件，注意：你自己创建依赖的<code>package</code>，也要放到<code>GOPATH</code>目录下，这样才能够被引用到。</li>
<li><code>pkg</code>：包含包对象，编译好的库文件</li>
<li><code>bin</code>：包含可执行命令</li>
</ul>
<p><code>GOPATH</code>相对于工作区的概念，可以分为<code>Go</code>工作区和用户工作区，<code>GOROOT</code>是<code>Go</code>核心工作区</p>
<p><code>GOPATH</code>可以包含多个包含 <code>Go</code> 语言源码文件、包文件和可执行文件的路径，而这些路径下又必须分别包含三个规定的目录：<code>src</code>、<code>pkg</code> 和 <code>bin</code></p>
<h3 id="程序的整体结构"><a href="#程序的整体结构" class="headerlink" title="程序的整体结构"></a>程序的整体结构</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">bin</span><br><span class="line">	xxx</span><br><span class="line">pkg</span><br><span class="line">	平台名/ 如：darwin_amd64、linux_amd64</span><br><span class="line">		mymath.a</span><br><span class="line">			xxx/</span><br><span class="line">				aa/</span><br><span class="line">					bb.a</span><br><span class="line">src</span><br><span class="line">	xxx</span><br><span class="line">		xxx.go</span><br><span class="line">	xx2</span><br><span class="line">		xx2.go</span><br></pre></td></tr></tbody></table></figure>
<h3 id="Hello-Go’s-World"><a href="#Hello-Go’s-World" class="headerlink" title="Hello Go’s World"></a>Hello Go’s World</h3><h4 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h4><p>新建一个文件<code>hello.go</code>，内容如下：</p>
<figure class="highlight go"><figcaption><span>文件名:hello.go</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main  <span class="comment">// 包、表明代码所在模块或包</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span>  <span class="comment">// 引入代码依赖</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	fmt.Println(<span class="string">"Hello,World!"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>使用<code>go run</code>直接运行这个文件，会直接输出：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">Hello,World!</span><br></pre></td></tr></tbody></table></figure>
<p>也可以通过<code>go build</code>编译这个<code>hello.go</code>文件，编译后产生一个静态连接且独立的二进制文件<code>hello.exe</code>，可以复制到不同机器上运行（容器相关）。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> build hello.<span class="keyword">go</span></span><br></pre></td></tr></tbody></table></figure>
<h4 id="关于程序入口"><a href="#关于程序入口" class="headerlink" title="关于程序入口"></a>关于程序入口</h4><p>与<code>Spring Boot</code>相似，以<code>application</code>为项目入口启动程序。<code>Go</code>的可执行程序需要一个应用程序的入口，文件夹和文件名的名字随意（文件名一般是<code>main.go</code>），但是必须是<code>main</code>包，既<code>package main</code>，还有必须是<code>main</code>方法，既<code>func main()</code>。所以<code>package</code>的名字可以和目录名不一致。</p>
<blockquote>
<p>在<code>Java</code>中，<code>package</code>的名字需要和目录一致</p>
</blockquote>
<p><strong>退出返回值</strong></p>
<p><code>func main()</code>是不支持返回值，我们可以一试：</p>
<figure class="highlight diff"><figcaption><span>go</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">func main() int {</span><br><span class="line">	fmt.Println("Hello,World!");</span><br><span class="line"><span class="addition">+ 	return 1 ;</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>然后编译并允许，结果如下：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># command-line-arguments</span></span><br><span class="line">.\hello.go:5:6: func main must have no arguments and no <span class="built_in">return</span> values</span><br></pre></td></tr></tbody></table></figure>
<p>可以通过<code>os</code>来返回值：</p>
<figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">func main()   {</span><br><span class="line">	fmt.Println("Hello,World!");</span><br><span class="line"><span class="deletion">-	return 1 ;</span></span><br><span class="line"><span class="addition">+	os.Exit(123);</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>结果如下：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">Hello,World!</span><br><span class="line"></span><br><span class="line">Process finished with <span class="built_in">exit</span> code 123</span><br></pre></td></tr></tbody></table></figure>
<h4 id="获取命令行参数"><a href="#获取命令行参数" class="headerlink" title="获取命令行参数"></a>获取命令行参数</h4><p>在<code>Java</code>中，<code>main</code>一般这样写，其中<code>String[] args</code>用来接收一些参数：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{</span><br><span class="line">    .....</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>然而在<code>Go</code>中不支持传入参数，<code>func main(arg  []string)</code>，这样在编译会产生错误提示。可以使用<code>os.Args</code>来获取命令行参数。</p>
<figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">func main( )   {</span><br><span class="line"><span class="deletion">-	fmt.Println("Hello,World!");</span></span><br><span class="line"><span class="addition">+   if len(os.Args)&gt;1 {</span></span><br><span class="line"><span class="addition">+		fmt.Println("Hello,World!",os.Args[1]);</span></span><br><span class="line"><span class="addition">+	}</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>然后在终端中输入：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">go run hello.go Zing</span><br></pre></td></tr></tbody></table></figure>
<p>结果：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">Hello,World! Zing</span><br></pre></td></tr></tbody></table></figure>
<p>其中：<code>os.Args[0]</code>会输出<code>hello.go</code>二进制文件的地址。 </p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="本地web文档"><a href="#本地web文档" class="headerlink" title="本地web文档"></a>本地web文档</h3><p>一般在命令中输入<code>go doc</code>来查找有点麻烦，资源网站访问有时加载很慢。所以可以尝试下在本地启动web文档，在一些比较老的版本中：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">godoc -http=localhost:8088</span><br></pre></td></tr></tbody></table></figure>
<p>在新版本中，默认不带有<code>godoc</code>，需要自行安装：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">go get golang.org/x/tools/cmd/godoc</span><br></pre></td></tr></tbody></table></figure>
<p>若遇到下载不成功的问题，考虑调整<code>Go</code>的代理地址。</p>
<p>安装成功后，在<code>GOPATH</code>中的<code>bin</code>文件夹里，在里面使用。也可以将其复制到<code>GOROOT</code>的<code>bin</code>中，这样在任意文件夹位置都可以使用。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li>《The Way To Go》：  <a href="https://www.cntofu.com/book/14/index.html" target="_blank" rel="noopener">https://www.cntofu.com/book/14/index.html</a></li>
<li>Go-Wiki ： <a href="http://code.google.com/p/go-wiki" target="_blank" rel="noopener">http://code.google.com/p/go-wiki</a></li>
<li>go 中文地址 ： <a href="https://golang.google.cn/" target="_blank" rel="noopener">https://golang.google.cn/</a></li>
</ol>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 常量与运算符</title>
    <url>/posts/Go_4.html</url>
    <content><![CDATA[<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul>
<li>常量的值在编译时就已经确定</li>
<li>常量的定义格式与变量基本相同</li>
<li>等号右侧必须是常量或者常量表达式</li>
<li>常量表达式中的函数必须是内置函数</li>
</ul>
<a id="more"></a>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">onst a <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="string">'A'</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	text   = <span class="string">"123"</span></span><br><span class="line">	length = <span class="built_in">len</span>(text)</span><br><span class="line">	num    = b * <span class="number">20</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> i, j, k = <span class="number">1</span>, <span class="string">"2"</span>, <span class="string">'3'</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	text2, length2, num2 = <span class="string">"456"</span>, <span class="built_in">len</span>(text2), k * <span class="number">10</span></span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="初始化规则与枚举"><a href="#初始化规则与枚举" class="headerlink" title="初始化规则与枚举"></a>初始化规则与枚举</h3><ul>
<li>在定义常量时，如果不提供初始值，则表示将使用上行的表达式</li>
<li>使用相同的表达式不代表具有相同的值</li>
<li>iota 是常量的计数器，从 0 开始，组中每定义1个常量自动递增1</li>
<li>通过初始化规则与 iota 可以达到枚举的效果</li>
<li>每遇得到一个 const 关键字， iota 就会重置为 0 </li>
</ul>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	<span class="comment">// a 和 b 都为 “A"</span></span><br><span class="line">	a = <span class="string">"A"</span></span><br><span class="line">	b</span><br><span class="line">	c = <span class="literal">iota</span></span><br><span class="line">	<span class="comment">// d 的值为 3</span></span><br><span class="line">	d</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	e = <span class="literal">iota</span></span><br><span class="line">	<span class="comment">// f 的值为 1</span></span><br><span class="line">	f</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 星期枚举</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	Monday = <span class="literal">iota</span></span><br><span class="line">	Tuesday</span><br><span class="line">	Wednesday</span><br><span class="line">	Thursday</span><br><span class="line">	Friday</span><br><span class="line">	Saturday</span><br><span class="line">	Sunday</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">A A <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br></pre></td></tr></tbody></table></figure>
<p>一般来说，在文件内中的常量尽量大写</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MAX_COUNT = <span class="number">1000</span></span><br><span class="line"><span class="comment">// 如果不想给包外使用，根据可见性规则，可以改为</span></span><br><span class="line"><span class="keyword">const</span> _MAX_COUNT = <span class="number">1000</span> </span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">const</span> cMAX_COUNT = <span class="number">1000</span></span><br></pre></td></tr></tbody></table></figure>
<h4 id="iota"><a href="#iota" class="headerlink" title="iota"></a>iota</h4><p>iota是表示无类型整数序数的预先声明的标识符，它是零索引的，Untyped int.</p>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>Go 中的运算符均是从左至右结合</p>
<p>优先级由高到低</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>运算符</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>一元</td>
<td><code>^</code>、<code>!</code></td>
</tr>
<tr>
<td>二元</td>
<td><code>*</code>、<code>/</code>、<code>%</code>、<code>&lt;&lt;</code>、<code>&gt;&gt;</code>、<code>&amp;</code>、<code>&amp;^</code></td>
</tr>
<tr>
<td></td>
<td><code>+</code>、<code>-</code>、`</td>
<td><code>、</code>^`</td>
</tr>
<tr>
<td></td>
<td><code>==</code>、<code>!=</code>、<code>&lt;</code>、<code>&lt;=</code>、<code>&gt;</code>、<code>&gt;=</code>、</td>
</tr>
<tr>
<td>专门用于并发的 channel</td>
<td><code>&lt;-</code></td>
</tr>
<tr>
<td></td>
<td><code>&amp;&amp;</code>、`</td>
<td></td>
<td>`</td>
</tr>
</tbody>
</table>
</div>
<h4 id="一元运算符"><a href="#一元运算符" class="headerlink" title="一元运算符"></a>一元运算符</h4><p>参与计算的数字只有一个</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">fmt.Println(^<span class="number">2</span>)</span><br><span class="line">fmt.Println(!<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果 </span></span><br><span class="line"><span class="number">-3</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></tbody></table></figure>
<h4 id="二元运算符"><a href="#二元运算符" class="headerlink" title="二元运算符"></a>二元运算符</h4><p>参与计算的数字有2个</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  5 0101</span></span><br><span class="line"><span class="comment"> 12 1100</span></span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line"><span class="comment">  &amp; 0100 -&gt; 4</span></span><br><span class="line"><span class="comment">  | 1101 -&gt; 13</span></span><br><span class="line"><span class="comment">  ^ 1001 -&gt; 9</span></span><br><span class="line"><span class="comment"> &amp;^ 0001 -&gt; 1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	a := <span class="number">5</span></span><br><span class="line">	b := <span class="number">12</span></span><br><span class="line">	fmt.Println(a &amp; b)</span><br><span class="line">	fmt.Println(a | b)</span><br><span class="line">	fmt.Println(a ^ b)</span><br><span class="line">	fmt.Println(a &amp;^ b)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="枚举与-iota"><a href="#枚举与-iota" class="headerlink" title="枚举与 iota"></a>枚举与 iota</h2><p>常量的 iota 与 <code>&lt;&lt;</code> 运算符实现计算机存储单位的枚举</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	B <span class="keyword">float64</span> = <span class="number">1</span> &lt;&lt; (<span class="literal">iota</span> * <span class="number">10</span>)</span><br><span class="line">	KB</span><br><span class="line">	MB</span><br><span class="line">	GB</span><br><span class="line">	TB</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>
<p>第一个常量中的iota为0，之后的KB会将上面的公式带入，不同时 iota 此时进行了 + 1 操作</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 类型与变量</title>
    <url>/posts/Go_3.html</url>
    <content><![CDATA[<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>可以包含数据的变量（或常量），可以使用不同的数据类型或类型来保存数据。使用 var 声明的变量的值会自动初始化为该类型的零值。类型定义了某个变量的值的集合与可对其进行操作的集合。</p>
<a id="more"></a>
<h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><p>类型可以是基本类型，如：int、float、bool、string；</p>
<ul>
<li><p>布尔型 bool</p>
<ul>
<li>长度：1字节</li>
<li>取值范围：[true,false]</li>
<li>注意事项：不可以用数字代表true或false</li>
</ul>
</li>
<li><p>整型：int/uint</p>
<ul>
<li>根据运行平台可能为32位或64位</li>
</ul>
</li>
<li><p>8位整型：int8/unit8</p>
<ul>
<li>长度：1字节</li>
<li>取值范围：-128~127 / 0~255</li>
</ul>
</li>
<li><p>16位整型：int16/unit16</p>
<ul>
<li>长度：2字节</li>
<li>取值范围： $ [ -2^{16}/2 \longrightarrow 2^{16}/2 - 1 ] $ / $ [ 0 \longrightarrow 2^{16}-1 ]$</li>
</ul>
</li>
<li><p>32位整型：int32（<em>rune别名</em>）/unit32</p>
<ul>
<li>长度：4字节</li>
<li>取值范围： $ [ -2^{32}/2 \longrightarrow 2^{32}/2 - 1 ] $ / $ [ 0 \longrightarrow 2^{32}-1 ]$ </li>
</ul>
</li>
<li><p>64位整型：int64/unit64</p>
<ul>
<li>长度：8字节</li>
<li>取值范围： $ [ -2^{64}/2 \longrightarrow 2^{64}/2 - 1 ] $ / $ [ 0 \longrightarrow 2^{64}-1 ]$ </li>
</ul>
</li>
<li><p>浮点型：float32/float64</p>
<ul>
<li>长度：4/8字节</li>
<li>小数点：精确到7/15位小数点</li>
</ul>
</li>
<li><p>字节型： byte（<em>unit8别名</em>）</p>
</li>
<li><p>复数： complex64/complex128</p>
<ul>
<li>长度：8/16字节</li>
</ul>
</li>
<li><p>足够保存指针的32位或64位整数型：uintptr</p>
</li>
<li><p>其他值类型：</p>
<ul>
<li>array</li>
<li>struct</li>
<li>string</li>
</ul>
</li>
<li><p>引用类型</p>
<ul>
<li>slice</li>
<li>map</li>
<li>chan</li>
</ul>
</li>
<li><p>接口类型</p>
<ul>
<li>interface</li>
</ul>
</li>
<li><p>函数类型</p>
<ul>
<li>func</li>
</ul>
</li>
</ul>
<blockquote>
<p>关于取值范围</p>
<p>有符号的需要区分正数，负数和零。基本是2的n次方，之后除于2，在取出0。</p>
<p>像：8位整型有符号是 - 2^8/2 ~ 2^8/2-1 就是 -128~127 / 0~255</p>
<p>无符号则是从0开始，最后再减一。</p>
</blockquote>
<h3 id="类型零值"><a href="#类型零值" class="headerlink" title="类型零值"></a>类型零值</h3><p>零值并不等于空值，而是当变量被声明为某种类型后的默认值，通常情况下值类型的默认值为0，<code>bool</code>为<code>false</code>，<code>string</code>为空字符串。结构化的类型没有真正的值，它使用 nil 作为默认值（在 Objective-C 中是 nil，在 Java 中是 null，在 C 和 C++ 中是NULL或 0）。值得注意的是，Go 语言中不存在类型继承。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="keyword">var</span> a [<span class="number">5</span>]<span class="keyword">int</span></span><br><span class="line">	fm.Println(a)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"># export </span><br><span class="line">[<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></tbody></table></figure>
<h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> (</span><br><span class="line">	<span class="keyword">byte</span> <span class="keyword">uint8</span></span><br><span class="line">	<span class="keyword">rune</span> <span class="keyword">int32</span></span><br><span class="line">	str <span class="keyword">string</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> param str</span><br><span class="line">param = <span class="string">"hello"</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="单个变量的声明与赋值"><a href="#单个变量的声明与赋值" class="headerlink" title="单个变量的声明与赋值"></a>单个变量的声明与赋值</h3><ul>
<li>变量的声明格式： var &lt;变量名称&gt; &lt;变量类型&gt;</li>
<li>变量的赋值格式：&lt;变量名称&gt; = &lt;表达式&gt;</li>
<li>声明的同时赋值： var &lt;变量名称&gt;[变量类型] = &lt;表达式&gt;</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var 变量名 [类型] [=] [初始值] </span><br><span class="line"></span><br><span class="line">// 变量的声明与赋值</span><br><span class="line">var a int</span><br><span class="line">a = 123</span><br><span class="line"></span><br><span class="line">// 同时赋值</span><br><span class="line">var b int = 2</span><br><span class="line">// 类型由系统推断</span><br><span class="line">var c = 321</span><br><span class="line"></span><br><span class="line">// 最简写法</span><br><span class="line">d := 233</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fm.Println(a,b,c,d)</span><br></pre></td></tr></tbody></table></figure>
<h4 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h4><p>如果在公开的自定义类型(结构)中，组合了只对自己可见的类型，且此类型的属性是公开的。其他地方在获取这个私有的类型时，只能通过<code>:=</code>去获取，因为无法直接使用这个类型，所以只能通过<code>:=</code>进行类型自动推断。</p>
<h4 id="如何用一行代码交换整数-i-和-j-的值"><a href="#如何用一行代码交换整数-i-和-j-的值" class="headerlink" title="如何用一行代码交换整数 i 和 j 的值"></a>如何用一行代码交换整数 i 和 j 的值</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">i,j=j,i;</span><br></pre></td></tr></tbody></table></figure>
<h3 id="多个变量的声明与赋值"><a href="#多个变量的声明与赋值" class="headerlink" title="多个变量的声明与赋值"></a>多个变量的声明与赋值</h3><ul>
<li>全局变量的声明可以使用<code>var()</code>方式进行简写</li>
<li>全局变量的声明不可以省略<code>var</code>，但可使用并行方式</li>
<li>所有变量都可以使用类型推断</li>
<li>局部变量不可以使用<code>var()</code>的方式简写，只能使用并行方式</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var (</span><br><span class="line">    // 使用常规方法</span><br><span class="line">	str1       = "hello "</span><br><span class="line">	// 使用并行方法以及类型推断</span><br><span class="line">	str2, str3 = "Go's", "World"</span><br><span class="line">	// str4 := 3 不可以省略 var</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">fm.Println(str1 + str2 + str3)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 多个变量的声明</span><br><span class="line">var a, b, c, d int</span><br><span class="line">// 多个变量的赋值</span><br><span class="line">a, b, c, d = 1, 2, 3, 4</span><br><span class="line"></span><br><span class="line">// 多个变量声明的同时赋值</span><br><span class="line">var e, f, g, h int = 5, 6, 7, 8</span><br><span class="line">// 省略变量类型，由系统推断</span><br><span class="line">var i, j, k, l = 9, 10, 11, 12</span><br><span class="line">// 多个变量声明与赋值的最简写法</span><br><span class="line">i, m, n, o := 13, 14, 15, 16</span><br><span class="line"></span><br><span class="line">fm.Println(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)</span><br><span class="line"></span><br><span class="line">// 赋值时忽略了第二个数，主要应用于函数的返回值中</span><br><span class="line">a, _, c, d := 1, 2, 3, 4 </span><br><span class="line">fm.Println(a,c, d)</span><br></pre></td></tr></tbody></table></figure>
<p>简写申明多个变量，一般称这种形式为 组</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 常量的定义 - 常量组</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	PI = <span class="number">3.14</span></span><br><span class="line">	const1 = <span class="string">"1"</span></span><br><span class="line">	const2 = <span class="number">2</span> </span><br><span class="line">	const3 = <span class="string">"3"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量的声明与赋值 - 全局变量组</span></span><br><span class="line"><span class="comment">// 在函数体内不支持这种简写</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	integerNum  = <span class="number">1</span></span><br><span class="line">	integerNum2 = <span class="number">1</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一般类型声明</span></span><br><span class="line"><span class="keyword">type</span> (</span><br><span class="line">	newType <span class="keyword">int</span></span><br><span class="line">	type1  <span class="keyword">float32</span></span><br><span class="line">	type2 <span class="keyword">string</span></span><br><span class="line">	type3 <span class="keyword">byte</span></span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="变量的类型转换"><a href="#变量的类型转换" class="headerlink" title="变量的类型转换"></a>变量的类型转换</h3><p>Go 是类型安全的</p>
<ul>
<li><p>不存在隐士转换，所有类型转换必须显式声明</p>
</li>
<li><p>转换只能发生在两种互相兼容的类型之间</p>
</li>
<li><p>类型转换的格式</p>
<ul>
<li><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;ValueA&gt; [:] = &lt;TypeOfValueA&gt;(&lt;ValueB&gt;)</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
</li>
</ul>
<p>例子：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var a float32 = 1.1</span><br><span class="line">b := int(a)</span><br><span class="line"></span><br><span class="line">fmt.Println(a,b)</span><br></pre></td></tr></tbody></table></figure>
<p>以下这段中，b最后的输出是<code>A</code>，而不是字符串<code>65</code>，<code>string()</code>表示将数据转换成文本格式，因为计算机中存储的任何东西本质上都是数字，因此此函数自然地认为我们需要将数字<code>65</code>表示为文本<code>A</code></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func main() {</span><br><span class="line">   var a int = 65</span><br><span class="line">   b := string(a)</span><br><span class="line">   fmt.Println(a,b)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>那么如何将数字65转成字符串65? 需要导入新的包<code>strconv</code>帮助进行转换。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">import (</span><br><span class="line">	"fmt"</span><br><span class="line">	"strconv"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">	var a int = 65</span><br><span class="line">	b := strconv.Itoa(a)</span><br><span class="line">	fmt.Println(a, b)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>strconv.Itoa</code>：将数字转成字符串</li>
<li><code>strconv.Atoi</code>：将字符串转成数字 </li>
</ul>
<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p><code>Go</code>不支持指针运算，也有垃圾回收机制。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestHello</span><span class="params">(t *testing.T)</span></span> {</span><br><span class="line">	a := <span class="number">1</span>;</span><br><span class="line">	aPtr := &amp;a;</span><br><span class="line">	t.Log(a, aPtr);</span><br><span class="line">	t.Logf(<span class="string">"%T %T"</span>, a, aPtr);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>结果：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">1 0xc00000c2c8</span><br><span class="line">int *int</span><br></pre></td></tr></tbody></table></figure>
<p>试一下指针运算：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestHello</span><span class="params">(t *testing.T)</span></span> {</span><br><span class="line">	a := <span class="number">1</span>;</span><br><span class="line">	aPtr := &amp;a;</span><br><span class="line">	t.Log(a, aPtr);</span><br><span class="line">+   aPtr = aPtr + <span class="number">1</span> ;</span><br><span class="line">	t.Logf(<span class="string">"%T %T"</span>, a, aPtr);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>结果：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">invalid operation: aPtr + 1 (mismatched types *int and int)</span><br></pre></td></tr></tbody></table></figure>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 数组</title>
    <url>/posts/Go_6.html</url>
    <content><![CDATA[<h2 id="数组-Array"><a href="#数组-Array" class="headerlink" title="数组 Array"></a>数组 Array</h2><ul>
<li>定义数组的格式：<code>var &lt;varName&gt; [n]&lt;type,n&gt; = 0</code></li>
<li>数组长度也是类型的一部分，因此具有不同长度的数组为不同类型</li>
<li>注意区分指向数组的指针和指针数组</li>
<li>数组在Go中为值类型</li>
<li>数组之间可以使用<code>==</code>或者<code>!=</code>进行比较，但是不可以使用<code>&gt;</code>或者<code>&lt;</code></li>
<li>可以使用<code>new</code>来创建数组，此方法返回一个指向数组的指针</li>
<li>Go支持多维数组</li>
</ul>
<a id="more"></a>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">arrF1</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="keyword">var</span> a [<span class="number">2</span>]<span class="keyword">int</span></span><br><span class="line">	fmt.Println(a)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 简写</span></span><br><span class="line">	a1 := [<span class="number">2</span>]<span class="keyword">int</span>{}</span><br><span class="line">	fmt.Println(a1)</span><br><span class="line"></span><br><span class="line">	a2 := [<span class="number">2</span>]<span class="keyword">int</span>{<span class="number">1</span>}</span><br><span class="line">	fmt.Println(a2)</span><br><span class="line"></span><br><span class="line">	a3 := [<span class="number">2</span>]<span class="keyword">int</span>{<span class="number">1</span>, <span class="number">2</span>}</span><br><span class="line">	fmt.Println(a3)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[0 0]</span><br><span class="line">[0 0]</span><br><span class="line">[1 0]</span><br><span class="line">[1 2]</span><br></pre></td></tr></tbody></table></figure>
<p> 如果字面值不够，会用0值来补充剩余的元素</p>
<h4 id="索引赋值"><a href="#索引赋值" class="headerlink" title="索引赋值"></a>索引赋值</h4><p>前4个数字为0，最后一个数字为1</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">a4 := [<span class="number">5</span>]<span class="keyword">int</span>{<span class="number">4</span>: <span class="number">1</span>}</span><br><span class="line">fmt.Println(a4)</span><br></pre></td></tr></tbody></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[0 0 0 0 1]</span><br></pre></td></tr></tbody></table></figure>
<p>在知道具体元素的情况下，也可以不声明数组长度</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">a5 := [...]<span class="keyword">int</span>{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>}</span><br><span class="line">fmt.Println(a5)</span><br></pre></td></tr></tbody></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[1 2 3 4 5]</span><br></pre></td></tr></tbody></table></figure>
<p>或者根据索引进行赋值，输出同上</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">a6 := [...]<span class="keyword">int</span>{<span class="number">0</span>: <span class="number">1</span>, <span class="number">1</span>: <span class="number">2</span>, <span class="number">2</span>: <span class="number">3</span>, <span class="number">3</span>: <span class="number">4</span>, <span class="number">4</span>: <span class="number">5</span>}</span><br><span class="line">fmt.Println(a6)</span><br></pre></td></tr></tbody></table></figure>
<p>前一位为索引，后一位为值</p>
<p>对于<code>a4 := [5]int{4: 1}</code>也可以使用另外一种写法，不指定数组长度</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">a7 := [...]int{4: 1}</span><br><span class="line">fmt.Println(a7)</span><br></pre></td></tr></tbody></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[0 0 0 0 1]</span><br></pre></td></tr></tbody></table></figure>
<h3 id="指向数组的指针和指针数组"><a href="#指向数组的指针和指针数组" class="headerlink" title="指向数组的指针和指针数组"></a>指向数组的指针和指针数组</h3><h4 id="指向数组的指针"><a href="#指向数组的指针" class="headerlink" title="指向数组的指针"></a>指向数组的指针</h4><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">a7 := [...]<span class="keyword">int</span>{<span class="number">4</span>: <span class="number">1</span>}	</span><br><span class="line"><span class="keyword">var</span> p *[<span class="number">5</span>]<span class="keyword">int</span> = &amp;a7</span><br><span class="line">fmt.Println(p)</span><br></pre></td></tr></tbody></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&amp;[0 0 0 0 1]</span><br></pre></td></tr></tbody></table></figure>
<p>即 p 指针是数组[0 0 0 0 1]的地址</p>
<h4 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h4><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">x, y := <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">a8 := [...]*<span class="keyword">int</span>{&amp;x, &amp;y}</span><br><span class="line">fmt.Println(a8)</span><br></pre></td></tr></tbody></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[0xc00001a178 0xc00001a180]</span><br></pre></td></tr></tbody></table></figure>
<h3 id="数组在Go中为值类型"><a href="#数组在Go中为值类型" class="headerlink" title="数组在Go中为值类型"></a>数组在Go中为值类型</h3><p>在其他语言中，数组为引用类型，在Go中为值类型，当函数中数组参数时</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func test(arr1){ </span><br><span class="line">	// 是将数组的值进行了copy，而不是传递地址给函数</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="数组比较"><a href="#数组比较" class="headerlink" title="数组比较"></a>数组比较</h3><p>数组类型要相同，长度一样</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">a9 := [...]<span class="keyword">int</span>{<span class="number">1</span>, <span class="number">2</span>}</span><br><span class="line">a10 := [...]<span class="keyword">int</span>{<span class="number">3</span>, <span class="number">4</span>}</span><br><span class="line">fmt.Println(a9 == a10)</span><br></pre></td></tr></tbody></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">false</span><br></pre></td></tr></tbody></table></figure>
<h3 id="new-关键字"><a href="#new-关键字" class="headerlink" title="new 关键字"></a>new 关键字</h3><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">p2 := <span class="built_in">new</span>([<span class="number">10</span>]<span class="keyword">int</span>)</span><br><span class="line">fmt.Println(p2)</span><br></pre></td></tr></tbody></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&amp;[0 0 0 0 0 0 0 0 0 0]</span><br></pre></td></tr></tbody></table></figure>
<p>指向数组的指针。</p>
<p>都可以使用下标的方式去修改数组</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">a := [<span class="number">10</span>]<span class="keyword">int</span>{}</span><br><span class="line">a[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">fmt.Println(a)</span><br><span class="line">p2 := <span class="built_in">new</span>([<span class="number">10</span>]<span class="keyword">int</span>)</span><br><span class="line">p2[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">fmt.Println(p2)</span><br></pre></td></tr></tbody></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[0 2 0 0 0 0 0 0 0 0]</span><br><span class="line">&amp;[0 2 0 0 0 0 0 0 0 0]</span><br></pre></td></tr></tbody></table></figure>
<h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func arrF2() {</span><br><span class="line">	a := [2][3]int{</span><br><span class="line">		{1, 1, 1},</span><br><span class="line">		{2, 2, 2},</span><br><span class="line">	}</span><br><span class="line">	fmt.Println(a)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[[1 1 1] [2 2 2]]</span><br></pre></td></tr></tbody></table></figure>
<p>索引赋值</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">arrF2</span><span class="params">()</span></span> {</span><br><span class="line">	a := [<span class="number">2</span>][<span class="number">3</span>]<span class="keyword">int</span>{</span><br><span class="line">		{<span class="number">1</span>:<span class="number">3</span>},</span><br><span class="line">		{<span class="number">0</span>:<span class="number">4</span>},</span><br><span class="line">	}</span><br><span class="line">	fmt.Println(a)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[[0 3 0] [4 0 0]]</span><br></pre></td></tr></tbody></table></figure>
<p>但是与一维不同的是，不能用<code>[...]</code></p>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">popF</span><span class="params">()</span></span>{</span><br><span class="line">	a := [...]<span class="keyword">int</span>{<span class="number">5</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">9</span>}</span><br><span class="line">	fmt.Println(a)</span><br><span class="line">	num := <span class="built_in">len</span>(a)</span><br><span class="line">	<span class="keyword">for</span> i:= <span class="number">0</span> ; i&lt;num ; i++{</span><br><span class="line">		<span class="keyword">for</span> j := i + <span class="number">1</span> ; j &lt;num ; j++ {</span><br><span class="line">			<span class="keyword">if</span> a[i] &lt; a[j] {</span><br><span class="line">				a[i],a[j] = a[j],a[i]</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	fmt.Println(a)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 切片</title>
    <url>/posts/Go_7.html</url>
    <content><![CDATA[<h2 id="切片Slice"><a href="#切片Slice" class="headerlink" title="切片Slice"></a>切片Slice</h2><p>切片本身并不是数组，是指向底层的数组，类似指针。其作为变长数组的替代方案，可以关联底层数组的局部或全部。同时这是一个引用类型，可以直接传教或者从底层数组获取生成。和数组一样，可以使用<code>len()</code>来获取元素个数，<code>cap()</code>获取容量。一般使用<code>mark()</code>进行创建，而不是<code>new ()</code>。</p>
<a id="more"></a>
<p>如果多个<code>slice</code>指向相同的底层数组，其中一个的值改变会影响到全部</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">make</span>([]T, <span class="built_in">len</span>, <span class="built_in">cap</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>其中cap是可以省略的，默认为与<code>len()</code>值相同</p>
<h3 id="简单例子"><a href="#简单例子" class="headerlink" title="简单例子"></a>简单例子</h3><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a []<span class="keyword">int</span></span><br><span class="line">fmt.Println(a)</span><br></pre></td></tr></tbody></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[]</span><br></pre></td></tr></tbody></table></figure>
<h3 id="取元素"><a href="#取元素" class="headerlink" title="取元素"></a>取元素</h3><h4 id="取前-后n位元素"><a href="#取前-后n位元素" class="headerlink" title="取前/后n位元素"></a>取前/后n位元素</h4><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sliceF2</span><span class="params">()</span></span> {</span><br><span class="line">	a := [<span class="number">10</span>]<span class="keyword">int</span>{<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>}</span><br><span class="line">	fmt.Println(a)</span><br><span class="line">	s1 := a[<span class="number">5</span>:<span class="number">10</span>]</span><br><span class="line">	fmt.Println(s1)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[1 2 4 5 6 7 8 9 10 0]</span><br><span class="line">[7 8 9 10 0]</span><br></pre></td></tr></tbody></table></figure>
<p>包含起始索引，不包含结尾的索引</p>
<p>可以简化下</p>
<figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line"><span class="deletion">-  s1 := a[5:10]</span></span><br><span class="line"><span class="addition">+  s1 := a[5:]  </span></span><br><span class="line">// 或者</span><br><span class="line"><span class="addition">+  s1 := a[5:len(a)]</span></span><br></pre></td></tr></tbody></table></figure>
<p>往前面取，索引从0~4</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">s1 := a[:5]</span><br></pre></td></tr></tbody></table></figure>
<h3 id="make"><a href="#make" class="headerlink" title="make"></a>make</h3><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sliceF3</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="comment">// 类型，元素个数，容量</span></span><br><span class="line">	s1 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">3</span>, <span class="number">10</span>)</span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(s1), <span class="built_in">cap</span>(s1))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>当元素个数小于等于容量时，不会进行扩容。当大于当前容量时，会分配长度位20且连续的内存块。每次超过时，容量值会翻倍，10-&gt;20-&gt;40。</p>
<p>容量默认为元素格式</p>
<h3 id="Reslice"><a href="#Reslice" class="headerlink" title="Reslice"></a>Reslice</h3><p>Reslice 时索引以被slice的切片为准，索引不可以超过被slice的切片容量<code>cap()</code>值，索引越界不会导致底层数组的重新分配而是引发错误</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sliceF4</span><span class="params">()</span></span> {</span><br><span class="line">	a := []<span class="keyword">byte</span>{<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>, <span class="string">'g'</span>, <span class="string">'h'</span>, <span class="string">'i'</span>, <span class="string">'j'</span>, <span class="string">'k'</span>}</span><br><span class="line">	sa := a[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line">	<span class="comment">// 在sa的范围内</span></span><br><span class="line">	sb := sa[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">	<span class="comment">// 超出sa的范围,但后面的内容是连续的</span></span><br><span class="line">	sc := sa[<span class="number">3</span>:<span class="number">5</span>]</span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(a))</span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(sa), <span class="built_in">len</span>(sa), <span class="built_in">cap</span>(sa))</span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(sb))</span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(sc))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">abcdefghijk</span><br><span class="line">cde 3 9</span><br><span class="line">cd</span><br><span class="line">fg</span><br></pre></td></tr></tbody></table></figure>
<p>sa 从<code>'c'</code>的位置开始，一直到<code>a</code>结束，是一个连续的，所分配的最大容器是 9</p>
<h3 id="Append"><a href="#Append" class="headerlink" title="Append"></a>Append</h3><p>在slice尾部追加元素，可以将一个slice追加到另一个slice的尾部，如果最终长度未超过追加到slice的容量则返回原始slice。如果超过，则将会重新分配数组并拷贝原始数据</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sliceF5</span><span class="params">()</span></span> {</span><br><span class="line">	s1 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">3</span>, <span class="number">6</span>)</span><br><span class="line">	fmt.Printf(<span class="string">"%p\n"</span>, s1)</span><br><span class="line">	s1 = <span class="built_in">append</span>(s1, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">	fmt.Printf(<span class="string">"%v %p\n"</span>, s1, s1)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">0xc0000d6030</span><br><span class="line">[0 0 0 1 2 3] 0xc0000d6030</span><br></pre></td></tr></tbody></table></figure>
<p>超出时，重新分配并拷贝原始数据</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sliceF5</span><span class="params">()</span></span> {</span><br><span class="line">	s1 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">3</span>, <span class="number">6</span>)</span><br><span class="line">	fmt.Printf(<span class="string">"%p\n"</span>, s1)</span><br><span class="line">	s1 = <span class="built_in">append</span>(s1, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">	fmt.Printf(<span class="string">"%v %p\n"</span>, s1, s1)</span><br><span class="line">	s1 = <span class="built_in">append</span>(s1, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">	fmt.Printf(<span class="string">"%v %p\n"</span>, s1, s1)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">0xc0000d6030</span><br><span class="line">[0 0 0 1 2 3] 0xc0000d6030</span><br><span class="line">[0 0 0 1 2 3 1 2 3] 0xc000086060</span><br></pre></td></tr></tbody></table></figure>
<h4 id="同时指向的影响"><a href="#同时指向的影响" class="headerlink" title="同时指向的影响"></a>同时指向的影响</h4><p>多个slice指向同一个底层数组，在操作数组时，会影响到所有关联的slice</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sliceF6</span><span class="params">()</span></span> {</span><br><span class="line">	a := []<span class="keyword">int</span>{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>}</span><br><span class="line">	s1 := a[<span class="number">0</span>:<span class="number">4</span>]</span><br><span class="line">	s2 := a[<span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line">	fmt.Println(s1, s2)</span><br><span class="line">	s1[<span class="number">1</span>] = <span class="number">123</span><span class="keyword">go</span></span><br><span class="line">	fmt.Println(s1, s2)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[1 2 3 4] [1 2 3]</span><br><span class="line">[1 123 3 4] [1 123 3]</span><br></pre></td></tr></tbody></table></figure>
<p>但对slice2进行append操作，并超过其<code>cap()</code>值时，之后的操作就不会影响到slice2</p>
<figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">func sliceF6(){</span><br><span class="line">	a := []int{1, 2, 3, 4, 5, 6}</span><br><span class="line">	s1 := a[0:4]</span><br><span class="line">	s2 := a[0:3]</span><br><span class="line">	fmt.Println(s1, s2)</span><br><span class="line"><span class="addition">+	s2 = append(s2, 1, 1, 1, 1, 1, 1, 1, 1)</span></span><br><span class="line">	a[1] = 123</span><br><span class="line">	fmt.Println(s1, s2)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[1 2 3 4] [1 2 3]</span><br><span class="line">[1 123 3 4] [1 2 3 1 1 1 1 1 1 1 1]</span><br></pre></td></tr></tbody></table></figure>
<h3 id="Copy"><a href="#Copy" class="headerlink" title="Copy"></a>Copy</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func sliceF8() {</span><br><span class="line">	s1 := []int{1, 2, 3, 4, 5, 6}</span><br><span class="line">	s2 := []int{7, 8, 9}</span><br><span class="line">	copy(s2, s1)</span><br><span class="line">	fmt.Println(s2)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[1 2 3]</span><br></pre></td></tr></tbody></table></figure>
<p>s2 中只有3个元素，将会copy前3个元素</p>
<p>只copy s1中的一部分，<code>s1[0:2]</code>是一个新的slice</p>
<figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line"><span class="addition">+ copy(s2, s1[0:2])</span></span><br><span class="line"><span class="deletion">- copy(s2, s1)</span></span><br></pre></td></tr></tbody></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[1 2 9]</span><br></pre></td></tr></tbody></table></figure>
<p>或者只是替换其中一部分</p>
<figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line"><span class="addition">+ copy(s2[1:2], s1[0:2])</span></span><br><span class="line"><span class="deletion">- copy(s2, s1)</span></span><br></pre></td></tr></tbody></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[7 1 9]</span><br></pre></td></tr></tbody></table></figure>
<p>得到一个完整的数组</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">s1 := []<span class="keyword">int</span>{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>}</span><br><span class="line">s3 := s1</span><br><span class="line">s4 := s1[<span class="number">0</span>:]</span><br><span class="line">s5 := s1[<span class="number">0</span>:<span class="built_in">len</span>(s1)]</span><br><span class="line">s6 := s1[:<span class="built_in">len</span>(s1)]</span><br><span class="line">s7 := s1[:]</span><br><span class="line">fmt.Println(s3)</span><br><span class="line">fmt.Println(s4)</span><br><span class="line">fmt.Println(s5)</span><br><span class="line">fmt.Println(s6)</span><br><span class="line">fmt.Println(s7)</span><br></pre></td></tr></tbody></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[1 2 3 4 5 6]</span><br><span class="line">[1 2 3 4 5 6]</span><br><span class="line">[1 2 3 4 5 6]</span><br><span class="line">[1 2 3 4 5 6]</span><br><span class="line">[1 2 3 4 5 6]</span><br></pre></td></tr></tbody></table></figure>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 控制语句</title>
    <url>/posts/Go_5.html</url>
    <content><![CDATA[<h2 id="if-控制"><a href="#if-控制" class="headerlink" title="if 控制"></a>if 控制</h2><ul>
<li>条件表达式没有括号</li>
<li>支持一个初始化表达式（可以是并行方式）</li>
<li>左大括号必须和条件语句或else在同一行</li>
<li>支持单行模式</li>
<li>初始化语句中的变量为block级别，同时隐藏外部同名变量</li>
</ul>
<a id="more"></a>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">a := <span class="literal">true</span></span><br><span class="line"><span class="keyword">if</span> a, b, c := <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>; a+b+c &gt; <span class="number">6</span> {</span><br><span class="line">	fmt.Println(<span class="string">"&gt;6"</span>)</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">    fmt.Println(<span class="string">"&lt;=6"</span>)</span><br><span class="line">    fmt.Println(a)</span><br><span class="line">}</span><br><span class="line">fmt.Println(a)</span><br></pre></td></tr></tbody></table></figure>
<h2 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h2><p>在 Go 中只有 for 一个循环语句关键字，没有 while ，但是支持3种形式</p>
<ul>
<li><p>初始化和步进表达式可以是多个值</p>
</li>
<li><p>条件语句每次循环都会被重新检查，因此不建议在条件语句中使用函数，尽量提前计算好并以变量或常量代替</p>
</li>
<li><p>左大括号必须和条件语句在同一行</p>
</li>
</ul>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 第一种</span></span><br><span class="line"></span><br><span class="line">a := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> {</span><br><span class="line">	a++</span><br><span class="line">	<span class="keyword">if</span> a &gt; <span class="number">3</span> {</span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line">fmt.Println(a)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果为4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种</span></span><br><span class="line">a := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> a &lt;= <span class="number">3</span>{</span><br><span class="line">    a ++</span><br><span class="line">}</span><br><span class="line">fmt.Println(a)</span><br><span class="line"><span class="comment">// 结果为4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三种</span></span><br><span class="line">a := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i:= <span class="number">0</span> ; i &lt; <span class="number">3</span> ; i++{</span><br><span class="line">    a ++</span><br><span class="line">}</span><br><span class="line"><span class="built_in">println</span>(a)</span><br><span class="line"><span class="comment">// 结果为4</span></span><br></pre></td></tr></tbody></table></figure>
<p>死循环</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> {</span><br><span class="line">	<span class="comment">// do something</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="switch-选择"><a href="#switch-选择" class="headerlink" title="switch 选择"></a>switch 选择</h2><ul>
<li><p>可以使用任何类型或表达式作为条件语句</p>
</li>
<li><p>不需要写break，一旦条件成立自动终止</p>
</li>
<li><p>如希望继续执行下一个case，需要使用 fallthrough 语句</p>
</li>
<li><p>支持一个初始化表达式（可以是并行方式），右侧需要跟分号</p>
</li>
<li><p>左大括号必须和条件语句在同一行</p>
</li>
</ul>
<p>例子1，<em>不需要写break，条件成立会自动终止</em>：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sF1</span><span class="params">()</span></span>{</span><br><span class="line">	a := <span class="number">1</span></span><br><span class="line">	<span class="keyword">switch</span> a {</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0</span> :</span><br><span class="line">		fmt.Println(<span class="string">"a=0"</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		fmt.Println(<span class="string">"a=1"</span>)</span><br><span class="line">	}</span><br><span class="line">	fmt.Println(a)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">a=1</span><br><span class="line">1</span><br></pre></td></tr></tbody></table></figure>
<p>例子2，如果希望继续执行下一个case，使用 <strong>fallthrough</strong> ：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sF2</span><span class="params">()</span></span> {</span><br><span class="line">	a := <span class="number">1</span></span><br><span class="line">	<span class="keyword">switch</span> {</span><br><span class="line">	<span class="keyword">case</span> a &gt;= <span class="number">0</span>:</span><br><span class="line">		fmt.Println(<span class="string">"a=0"</span>)</span><br><span class="line">		<span class="keyword">fallthrough</span></span><br><span class="line">	<span class="keyword">case</span> a &gt;= <span class="number">1</span>:</span><br><span class="line">		fmt.Println(<span class="string">"a=1"</span>)</span><br><span class="line">	}</span><br><span class="line">	fmt.Println(a)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">a=0</span><br><span class="line">a=1</span><br><span class="line">1</span><br></pre></td></tr></tbody></table></figure>
<p>例子3，支持一个初始化表达式，需要分号结尾 ：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sF3</span><span class="params">()</span></span> {</span><br><span class="line">	a := <span class="number">1</span></span><br><span class="line">	<span class="keyword">switch</span> b := <span class="number">1</span>; {</span><br><span class="line">	<span class="keyword">case</span> a+b &gt; <span class="number">2</span>:</span><br><span class="line">		fmt.Println(<span class="string">"a+b&gt;2"</span>)</span><br><span class="line">	<span class="keyword">case</span> a+b == <span class="number">2</span>:</span><br><span class="line">		fmt.Println(<span class="string">"a+b=2"</span>)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Println(<span class="string">"a+b&lt;2"</span>)</span><br><span class="line">	}</span><br><span class="line">	fmt.Println(a)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出为：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">a+b&lt;=<span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>
<p>在 switch 中 b 的作用域在 switch中有效，所以外面是输出不到它的信息</p>
<h2 id="跳转语句-与-标签"><a href="#跳转语句-与-标签" class="headerlink" title="跳转语句 与 标签"></a>跳转语句 与 标签</h2><ul>
<li>3个语句都可以配合标签使用</li>
<li>标签名区分大小写，若不适用会造成编译错误</li>
<li>break 与 continue 配合标签可用于多层循环的跳出</li>
<li>goto 是调整执行位置，与其他2个语句配合标签的结果并不相同</li>
</ul>
<h3 id="break"><a href="#break" class="headerlink" title="break"></a>break</h3><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">breakF</span><span class="params">()</span></span> {</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ {</span><br><span class="line">      <span class="keyword">if</span> i &gt; <span class="number">1</span> {</span><br><span class="line">         fmt.Println(i)</span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">      }</span><br><span class="line">   }</span><br><span class="line">   fmt.Println(<span class="string">"over"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">2</span><br><span class="line">over</span><br></pre></td></tr></tbody></table></figure>
<p>当 i &gt; 1 时，输出当前的值 break 结束循环，并继续执行剩下的代码</p>
<p>拥有2层for时，跳到最外面，使用标签，会跳到与标签同一级，然后执行for后面的代码</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">breakF1</span><span class="params">()</span></span> {</span><br><span class="line">LABEL:</span><br><span class="line">	<span class="keyword">for</span> {</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ {</span><br><span class="line">			<span class="keyword">if</span> i &gt; <span class="number">2</span> {</span><br><span class="line">				fmt.Println(<span class="string">"break to label，i: "</span>, i)</span><br><span class="line">				<span class="keyword">break</span> LABEL</span><br><span class="line">			} <span class="keyword">else</span> {</span><br><span class="line">				fmt.Println(i)</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	fmt.Println(<span class="string">"over"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">break to label，i:  3</span><br><span class="line">over</span><br></pre></td></tr></tbody></table></figure>
<h3 id="goto"><a href="#goto" class="headerlink" title="goto"></a>goto</h3><p>如果将 break 改为 goto ，将会导致重新进入一次循环，导致死循环</p>
<figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">if i &gt; 2 {</span><br><span class="line">    fmt.Println("break to label，i: ", i)</span><br><span class="line"><span class="deletion">-   break LABEL</span></span><br><span class="line"><span class="addition">+   goto LBAEL</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>可以将标签放在 for 之后</p>
<figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line"><span class="deletion">- LABEL:</span></span><br><span class="line">	for {</span><br><span class="line">		for i := 0; i &lt; 10; i++ {</span><br><span class="line">			if i &gt; 2 {</span><br><span class="line">				fmt.Println("break to label，i: ", i)</span><br><span class="line"><span class="deletion">-               break LABEL</span></span><br><span class="line"><span class="addition">+               goto LBAEL</span></span><br><span class="line">			} else {</span><br><span class="line">				fmt.Println(i)</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"><span class="addition">+ LABEL:	</span></span><br><span class="line">	fmt.Println("over")</span><br></pre></td></tr></tbody></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">break to label，i:  3</span><br><span class="line">over</span><br></pre></td></tr></tbody></table></figure>
<h3 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h3><p>例子：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">continueF1</span><span class="params">()</span></span> {</span><br><span class="line">LABEL:</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ {</span><br><span class="line">		fmt.Println(<span class="string">"before i"</span>, i)</span><br><span class="line">		<span class="keyword">for</span> {</span><br><span class="line">			<span class="keyword">continue</span> LABEL</span><br><span class="line">			fmt.Println(i)</span><br><span class="line">		}</span><br><span class="line">		fmt.Println(<span class="string">"after i"</span>, i)</span><br><span class="line">	}</span><br><span class="line">	fmt.Println(<span class="string">"over"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">before i 0</span><br><span class="line">before i 1</span><br><span class="line">before i 2</span><br><span class="line">over</span><br></pre></td></tr></tbody></table></figure>
<p>在 continue 之后都不会执行</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">continueF2</span><span class="params">()</span></span> {</span><br><span class="line">LABEL:</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ {</span><br><span class="line">		<span class="keyword">for</span> {</span><br><span class="line">			fmt.Print(i)</span><br><span class="line">			<span class="keyword">continue</span> LABEL</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">0123456789</span><br></pre></td></tr></tbody></table></figure>
<p>接下将换成 goto 发现输出都是0，其变成了死循环。goto 是调整执行位置</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">000000000000000000000000000000000000000000000000000000000000000000000..............</span><br></pre></td></tr></tbody></table></figure>
<p>将 label 放在 goto 的后面</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func continueF2() {</span><br><span class="line">	for i := 0; i &lt; 10; i++ {</span><br><span class="line">		for {</span><br><span class="line">			fmt.Print(i)</span><br><span class="line">			continue LABEL</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">LABEL:</span><br><span class="line">	// xxxxx</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 程序的基本结构和要素</title>
    <url>/posts/Go_2.html</url>
    <content><![CDATA[<h2 id="内置关键字"><a href="#内置关键字" class="headerlink" title="内置关键字"></a>内置关键字</h2><p>均为小写，关键字不能作为标识符使用</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>break</th>
<th>default</th>
<th>func</th>
<th>interface</th>
<th>select</th>
</tr>
</thead>
<tbody>
<tr>
<td>case</td>
<td>defer</td>
<td>go</td>
<td>map</td>
<td>struct</td>
</tr>
<tr>
<td>chan</td>
<td>else</td>
<td>goto</td>
<td>package</td>
<td>switch</td>
</tr>
<tr>
<td>const</td>
<td>fallthrough</td>
<td>if</td>
<td>range</td>
<td>type</td>
</tr>
<tr>
<td>continue</td>
<td>for</td>
<td>import</td>
<td>return</td>
<td>var</td>
</tr>
</tbody>
</table>
</div>
<a id="more"></a>
<p>除了以上，还有一些预定义标识符</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>append</th>
<th>bool</th>
<th>byte</th>
<th>cap</th>
<th>close</th>
<th>complex</th>
<th>complex64</th>
<th>complex128</th>
<th>uint16</th>
</tr>
</thead>
<tbody>
<tr>
<td>copy</td>
<td>false</td>
<td>float32</td>
<td>float64</td>
<td>imag</td>
<td>int</td>
<td>int8</td>
<td>int16</td>
<td>uint32</td>
</tr>
<tr>
<td>int32</td>
<td>int64</td>
<td>iota</td>
<td>len</td>
<td>make</td>
<td>new</td>
<td>nil</td>
<td>panic</td>
<td>uint64</td>
</tr>
<tr>
<td>print</td>
<td>println</td>
<td>real</td>
<td>recover</td>
<td>string</td>
<td>true</td>
<td>uint</td>
<td>uint8</td>
<td>uintptr</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p> 程序的代码通过语句来实现结构化。每个语句不需要像 C 家族中的其它语言一样以分号 <code>;</code> 结尾，因为这些工作都将由 Go 编译器自动完成</p>
</blockquote>
<h2 id="Go-包"><a href="#Go-包" class="headerlink" title="Go 包"></a>Go 包</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>每个Go文件都属于且仅属于一个包,一个包可以由许多以<code>.go</code>为扩展名的源文件组成，因此文件名和包名一般来说都是不相同的。必须在源文件中非注释的第一行中指明该文件属于哪个包，<code>package main</code>。<code>package main</code>表示一个可独立执行的程序，每个Go应用程序都包含一个名为<code>main</code>的包。所有的包名应该都是小写</p>
<p>如果想要构建一个程序，则包和包内的文件都必须以正确的顺序进行编译。包的依赖关系决定了其构建顺序。</p>
<p>属于同一个包的源文件必须全部被一起编译，一个包即是编译时的一个单元，因此根据惯例，每个目录都只包含一个包。</p>
<p><strong>如果对一个包进行更改或重新编译，所有引用了这个包的客户端程序都必须全部重新编译。</strong></p>
<p>Go 中的包模型采用了显式依赖关系的机制来达到快速编译的目的，编译器会从后缀名为 <code>.o</code> 的对象文件（需要且只需要这个文件）中提取传递依赖类型的信息。</p>
<p>如果 <code>A.go</code> 依赖 <code>B.go</code>，而 <code>B.go</code> 又依赖 <code>C.go</code>：</p>
<ul>
<li>编译 <code>C.go</code>, <code>B.go</code>, 然后是 <code>A.go</code>.</li>
<li>为了编译 <code>A.go</code>, 编译器读取的是 <code>B.o</code> 而不是 <code>C.o</code>.</li>
</ul>
<h3 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h3><p>如果包名不是以 <code>.</code> 或 <code>/</code> 开头，如 <code>"fmt"</code> 或者 <code>"container/list"</code>，则 Go 会在全局文件进行查找；如果包名以 <code>./</code> 开头，则 Go 会在相对目录中查找；如果包名以 <code>/</code> 开头（在 Windows 下也可以这样使用），则会在系统的绝对路径中查找。</p>
<p>导入单个包：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 单个包</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br></pre></td></tr></tbody></table></figure>
<p>多个包</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 多个</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"os"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多个</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>
<p>别名</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 别名 alias</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	io <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	io.Println(<span class="string">"123"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>省略</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 省略调用，不建议使用</span></span><br><span class="line"><span class="keyword">import</span> . <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">Println(<span class="string">"1231132"</span>)</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p> 如果导入一个包没有是使用它，在构建程序时，会抛出错误<code>imported and not used: os</code></p>
</blockquote>
<h3 id="可见性规则"><a href="#可见性规则" class="headerlink" title="可见性规则"></a>可见性规则</h3><p>Go 语言中，使用大小写来决定该常量、变量、类型、接口、结构或函数是否可以被外部包所调用：</p>
<p>根绝约定，函数名首字母小写即为 <code>private</code>，对包外不可见，在包内是可以可见并可用的</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func getField(i int)</span><br></pre></td></tr></tbody></table></figure>
<p>函数名首字母大写为 <code>public</code>，被视为导出</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func Printf(i int)</span><br></pre></td></tr></tbody></table></figure>
<h2 id="func-函数"><a href="#func-函数" class="headerlink" title="func 函数"></a>func 函数</h2><p>main 函数是每一个可执行程序所必须包含的，一般来说都是在启动后第一个执行的函数，如果有 init() 函数则会先执行该函数。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 当前程序的包名</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">// 导入其他的包</span><br><span class="line">import fm "fmt"</span><br><span class="line"></span><br><span class="line">func init() {</span><br><span class="line">	fm.Println("-- func init execute --")</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">	// 输出</span><br><span class="line">	fm.Printf("Hello,Go\n你好，狗")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">-- func init execute --</span><br><span class="line">Hello,Go</span><br><span class="line">你好，狗</span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></tbody></table></figure>
<p>如果你的 main 包的源代码没有包含 main 函数，则会引发构建错误 <code>undefined: main.main</code>。main 函数既没有参数，也没有返回类型（与 C 家族中的其它语言恰好相反）。如果你不小心为 main 函数添加了参数或者返回类型，将会引发构建错误：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func main must have no arguments and no return values results.</span><br><span class="line">或者</span><br><span class="line">Run after build is not possible Main file has non-main package or doesn't contain main function</span><br></pre></td></tr></tbody></table></figure>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>几乎所有全局作用域的类型、常量、变量、函数和被导出的对象都应该有一个合理的注释。如果这种注释（称为文档注释）出现在函数前面，例如函数 Abcd，则要以 <code>"Abcd..."</code> 作为开头。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// enterOrbit causes Superman to fly into low Earth orbit, a position</span></span><br><span class="line"><span class="comment">// that presents several possibilities for planet salvation.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">enterOrbit</span><span class="params">()</span> <span class="title">error</span></span> {</span><br><span class="line">   ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go func</title>
    <url>/posts/Go_9.html</url>
    <content><![CDATA[<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>Go 函数不支持嵌套，重载和默认参数</p>
<p>但支持以下特性：</p>
<ul>
<li>无需声明原型，不定长度变参，多返回值，命名返回值参数，匿名函数，闭包</li>
</ul>
<p>定义函数使用关键字<code>func</code>，且左大括号不能另起一行</p>
<p>函数也可以作为一种类型使用</p>
<a id="more"></a>
<h3 id="无需声明原型"><a href="#无需声明原型" class="headerlink" title="无需声明原型"></a>无需声明原型</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func funcTest1(a int, b string) (int, string, int) {</span><br><span class="line">	fmt.Println(a, b)</span><br><span class="line">	return 1, "123", 123</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">	fmt.Println(funcTest1(1, "234"))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="多参数同类型"><a href="#多参数同类型" class="headerlink" title="多参数同类型"></a>多参数同类型</h3><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcTest2</span><span class="params">(a, b, c <span class="keyword">int</span>)</span></span> {</span><br><span class="line">	fmt.Println(a, b, c)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcTest2</span><span class="params">(a, b, c <span class="keyword">int</span>)</span> <span class="params">(a1, b1, c1 <span class="keyword">int</span>)</span></span> {</span><br><span class="line">	fmt.Println(a, b, c)</span><br><span class="line">	a1, b1, c1 = a+<span class="number">1</span>, b+<span class="number">1</span>, c+<span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>return</code>与返回声明中的参数名一样就可以省略不用写，不过一般情况下，按照编码要求还是需要写得 </p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcTest2</span><span class="params">(a, b, c <span class="keyword">int</span>)</span> <span class="params">(a1, b1, c1 <span class="keyword">int</span>)</span></span> {</span><br><span class="line">	fmt.Println(a, b, c)</span><br><span class="line">    a1, b1, c1 = a+<span class="number">1</span>, b+<span class="number">1</span>, c+<span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> a1, b1, c1</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="不定长度变参"><a href="#不定长度变参" class="headerlink" title="不定长度变参"></a>不定长度变参</h3><p>java 中参数可变的例子</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sumUp</span><span class="params">(<span class="keyword">int</span>... values)</span> </span>{    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在go中也可以</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcTest3</span><span class="params">(a ...<span class="keyword">int</span>)</span> <span class="title">int</span></span> {</span><br><span class="line">	max := math.MinInt64</span><br><span class="line">	<span class="keyword">for</span> i, _ := <span class="keyword">range</span> a {</span><br><span class="line">		fmt.Println(a[i])</span><br><span class="line">		<span class="keyword">if</span> a[i] &gt; max {</span><br><span class="line">			max = a[i]</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> max</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>...[type]</code>必须是最后一个参数，是一个<code>slice</code></p>
<p>以下是错误的</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcTest</span><span class="params">(a ...<span class="keyword">int</span>, b <span class="keyword">string</span>)</span></span></span><br></pre></td></tr></tbody></table></figure>
<p>正确</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funTest</span><span class="params">(b <span class="keyword">string</span>, a ...<span class="keyword">int</span>)</span></span></span><br></pre></td></tr></tbody></table></figure>
<p><code>...[type]</code>可变参数可以看作是一个<code>slice</code>，但是与<code>slice</code>不同的是，不是引用类型，实际上得到是一个值拷贝。</p>
<p>如果参数是<code>slice</code>，是拷贝<code>slice</code>的内存地址，而不是值。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcTest5</span><span class="params">(s []<span class="keyword">int</span>)</span></span> {</span><br><span class="line">	<span class="keyword">for</span> i,v := <span class="keyword">range</span> s {</span><br><span class="line">		s[i] = v + <span class="number">1</span> </span><br><span class="line">	}</span><br><span class="line">	fmt.Println(<span class="string">"func:"</span>, s)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	s := []<span class="keyword">int</span>{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>}</span><br><span class="line">	fmt.Println(<span class="string">"before:"</span>, s)</span><br><span class="line">	funcTest5(s)</span><br><span class="line">	fmt.Println(<span class="string">"after"</span>, s)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">before: [1 2 3]</span><br><span class="line">func: [2 3 4]</span><br><span class="line">after [2 3 4]</span><br></pre></td></tr></tbody></table></figure>
<p>一般类型都是值拷贝，如果需要影响到传入的值，需要传入值的地址。</p>
<figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line"><span class="deletion">- func funcTest5(s []int) {</span></span><br><span class="line"><span class="addition">+ func funcTest5(s []int, a *int) {</span></span><br><span class="line">  	for i, v := range s {</span><br><span class="line">		s[i] = v + 1</span><br><span class="line">	}</span><br><span class="line"><span class="addition">+	*a = 2</span></span><br><span class="line"><span class="deletion">-   fmt.Println("func:", s)</span></span><br><span class="line"><span class="addition">+	fmt.Println("func:", s, a)</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">	s := []int{1, 2, 3}</span><br><span class="line"><span class="deletion">-	fmt.Println("before:", s)</span></span><br><span class="line"><span class="deletion">-	funcTest5(s)</span></span><br><span class="line"><span class="deletion">-	fmt.Println("after", s)</span></span><br><span class="line"><span class="addition">+	a := 1</span></span><br><span class="line"><span class="addition">+	fmt.Println("before:", s, a)</span></span><br><span class="line"><span class="addition">+	funcTest5(s, &amp;a)</span></span><br><span class="line"><span class="addition">+	fmt.Println("after", s, a)</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">before: [1 2 3] 1</span><br><span class="line">func: [2 3 4] 0xc00001a098</span><br><span class="line">after [2 3 4] 2</span><br></pre></td></tr></tbody></table></figure>
<h3 id="函数也可以作为一种类型使用"><a href="#函数也可以作为一种类型使用" class="headerlink" title="函数也可以作为一种类型使用"></a>函数也可以作为一种类型使用</h3><p>这个特性与JavaScript中差不多，定义一个变量等于函数，使用这个变量相当于使用这个函数。<em>在Go中一切皆类型</em></p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcTest6</span><span class="params">()</span></span> {</span><br><span class="line">	fmt.Println(<span class="string">"hello everyone"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	a := funcTest6</span><br><span class="line">	a()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">hello everyone</span><br></pre></td></tr></tbody></table></figure>
<h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	a := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">		fmt.Println(<span class="string">"这是一个匿名函数"</span>)</span><br><span class="line">	}</span><br><span class="line">	a()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>没有命令函数名称。是一个代码块。</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcTest7</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">int</span></span> {</span><br><span class="line">	fmt.Println(<span class="string">"func test 7"</span>, x, &amp;x)</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(y <span class="keyword">int</span>)</span> <span class="title">int</span></span> {</span><br><span class="line">		x++</span><br><span class="line">		fmt.Println(<span class="string">"func test 7 "</span>, x, &amp;x, y)</span><br><span class="line">		<span class="keyword">return</span> x + y</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	f := funcTest7(<span class="number">10</span>)</span><br><span class="line">	fmt.Println(f(<span class="number">1</span>))</span><br><span class="line">	fmt.Println(f(<span class="number">2</span>))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func test 7 10 0xc00001a098</span><br><span class="line">func test 7  11 0xc00001a098 1</span><br><span class="line">12</span><br><span class="line">func test 7  12 0xc00001a098 2</span><br><span class="line">14</span><br></pre></td></tr></tbody></table></figure>
<p>3次输出<code>x</code>的地址是一样的。</p>
<h2 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h2><p>执行方式类似其他语言中的<strong>析构函数</strong>，在函数体执行结束后按照<strong>调用顺序的相反顺序逐个执行</strong>（先进后出，栈堆）。即使函数发生严重错误也会执行，支持匿名函数的调用。通常用于资源清理，文件关闭，解锁以及记录时间等操作。通过与匿名函数配合可在<code>return</code>之后修改函数计算结果。如果函数体内某个变量作为<code>defer</code>时匿名函数的参数，则在定义<code>defer</code>时即已经获得了拷贝，否则引用某个变量的地址。。</p>
<p>Go 中没有异常机制，但是有 <code>panic/recover</code>模式来处理错误</p>
<p><code>panic</code>可以在任何地方引发，但是<code>recover</code>只有在<code>defer</code>调用的函数中有效</p>
<h3 id="相反顺序"><a href="#相反顺序" class="headerlink" title="相反顺序"></a>相反顺序</h3><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	fmt.Println(<span class="string">"a"</span>)</span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="string">"b"</span>)</span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="string">"c"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">a</span><br><span class="line">c</span><br><span class="line">b</span><br></pre></td></tr></tbody></table></figure>
<p>按照<strong>调用顺序的相反顺序逐个执行</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ {</span><br><span class="line">		<span class="keyword">defer</span> fmt.Println(i)</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">2</span><br><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></tbody></table></figure>
<h3 id="闭包-1"><a href="#闭包-1" class="headerlink" title="闭包"></a>闭包</h3><p>在这个匿名函数中，<code>i</code>被当作一个地址的引用，引用这个局部变量，当循环结束时，i = 3 。在main函数结束后，开始执行<code>defer</code>中的代码。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ {</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">		fmt.Println(i)</span><br><span class="line">	}()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">3</span><br><span class="line">3</span><br><span class="line">3</span><br></pre></td></tr></tbody></table></figure>
<p>可以改成这样：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ {</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(a <span class="keyword">int</span>)</span></span> {</span><br><span class="line">		fmt.Println(a)</span><br><span class="line">	}(i)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">2</span><br><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></tbody></table></figure>
<h3 id="panic"><a href="#panic" class="headerlink" title="panic"></a>panic</h3><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcTest8</span><span class="params">()</span></span>{</span><br><span class="line">	fmt.Println(<span class="string">"func test 8"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcTest9</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="built_in">panic</span>(<span class="string">"func test 9"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcTest10</span><span class="params">()</span></span>{</span><br><span class="line">	fmt.Println(<span class="string">"func test 10"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	funcTest8()</span><br><span class="line">	funcTest9()</span><br><span class="line">	funcTest10()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func test 8</span><br><span class="line">panic: func test 9</span><br><span class="line"></span><br><span class="line">goroutine 1 [running]:</span><br><span class="line">main.funcTest9(...)</span><br><span class="line">... 省略</span><br></pre></td></tr></tbody></table></figure>
<p>并没有继续往下执行到test10</p>
<h4 id="recover"><a href="#recover" class="headerlink" title="recover()"></a>recover()</h4><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">func funcTest9() {</span><br><span class="line"><span class="addition">+	defer func() {</span></span><br><span class="line"><span class="addition">+		if err := recover(); err != nil {</span></span><br><span class="line"><span class="addition">+			fmt.Println("Recover in test 9")</span></span><br><span class="line"><span class="addition">+		}</span></span><br><span class="line"><span class="addition">+	}()</span></span><br><span class="line">	panic("func test 9")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>需要在<code>panic</code>前面加入以上代码，输出</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func test 8</span><br><span class="line">Recover in test 9</span><br><span class="line">func test 10</span><br></pre></td></tr></tbody></table></figure>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="keyword">var</span> fs = [<span class="number">4</span>]<span class="function"><span class="keyword">func</span><span class="params">()</span></span>{}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ {</span><br><span class="line">		<span class="keyword">defer</span> fmt.Println(<span class="string">"defer i = "</span>, i)</span><br><span class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">			fmt.Println(<span class="string">"defer_closure i = "</span>, i)</span><br><span class="line">		}()</span><br><span class="line">		fs[i] = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">			fmt.Println(<span class="string">"closure i = "</span>, i)</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, f := <span class="keyword">range</span> fs {</span><br><span class="line">		f()</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">closure i =  4</span><br><span class="line">closure i =  4</span><br><span class="line">closure i =  4</span><br><span class="line">closure i =  4</span><br><span class="line">defer_closure i =  4</span><br><span class="line">defer i =  3</span><br><span class="line">defer_closure i =  4</span><br><span class="line">defer i =  2</span><br><span class="line">defer_closure i =  4</span><br><span class="line">defer i =  1</span><br><span class="line">defer_closure i =  4</span><br><span class="line">defer i =  0</span><br></pre></td></tr></tbody></table></figure>
<p><code>fs[i]()</code> 中的<code>i</code>，因为使用的是外部的<code>i</code>，实际上调用外部 <code>i</code>的地址，当循环体结束时，<code>i = 4</code> ，所以输出<code>closure i =  4</code></p>
<p>defer 使用的匿名函数与上面一样，是闭包的思想。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go map</title>
    <url>/posts/Go_8.html</url>
    <content><![CDATA[<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>类似其他语言中的哈希表或者字典，以<code>key-value</code>形式存储数据，<code>key</code>必须是支持<code>==</code>或者<code>!-</code>比较运算的类型，不可以是函数，<code>map</code>或者<code>slice</code>。</p>
<p><code>Map</code> 查找比线性搜索快很多，但比使用索引访问数据的类型慢100倍。</p>
<p><code>Map</code>使用<code>make()</code>创建，支持<code>:=</code>简写方式</p>
<p><code>make([keyType]valueType, cap)</code>，其中<code>cap</code>表示容量，可省略</p>
<p>超出容量时会自动扩容，但尽量提供一个合理的初始值</p>
<p>键值对不存在时会自动添加，使用<code>delete()</code>删除某键值对</p>
<p>使用<code>for range</code>对<code>map</code>和<code>slice</code>进行迭代操作</p>
<a id="more"></a>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapF1</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="keyword">var</span> m1 <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span></span><br><span class="line">	m1 = <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>{}</span><br><span class="line">	fmt.Println(m1)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> m2 <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span></span><br><span class="line">	m2 = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>)</span><br><span class="line">	<span class="comment">// var m2 map[int]string = make(map[int]string)</span></span><br><span class="line">	fmt.Println(m2)</span><br><span class="line"></span><br><span class="line">	m3 := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>{}</span><br><span class="line">	fmt.Println(m3)</span><br><span class="line"></span><br><span class="line">	m4 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>)</span><br><span class="line">	fmt.Println(m4)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">map[]</span><br><span class="line">map[]</span><br><span class="line">map[]</span><br><span class="line">map[]</span><br></pre></td></tr></tbody></table></figure>
<h3 id="元素操作"><a href="#元素操作" class="headerlink" title="元素操作"></a>元素操作</h3><h4 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h4><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapF2</span><span class="params">()</span></span>{</span><br><span class="line">	m := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>{}</span><br><span class="line">	m[<span class="string">"name"</span>] = <span class="string">"Bob"</span></span><br><span class="line">	m[<span class="string">"age"</span>] = <span class="string">"18"</span></span><br><span class="line">	fmt.Println(m)</span><br><span class="line"></span><br><span class="line">	a := m[<span class="string">"name"</span>]</span><br><span class="line">	fmt.Println(a)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">map[age:18 name:Bob]</span><br><span class="line">Bob</span><br></pre></td></tr></tbody></table></figure>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line"><span class="addition">+ delete(m,"name")</span></span><br><span class="line"><span class="addition">+ fmt.Println(m)</span></span><br></pre></td></tr></tbody></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">map[age:18]</span><br></pre></td></tr></tbody></table></figure>
<h3 id="复杂一点的map"><a href="#复杂一点的map" class="headerlink" title="复杂一点的map"></a>复杂一点的map</h3><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapF3</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="comment">// 1 : {1:"123"}</span></span><br><span class="line">	m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>)</span><br><span class="line">	m2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>)</span><br><span class="line">	m2[<span class="number">0</span>] = <span class="string">"Bob"</span></span><br><span class="line"></span><br><span class="line">	m[<span class="number">0</span>] = m2</span><br><span class="line"></span><br><span class="line">	fmt.Println(m2)</span><br><span class="line">	fmt.Println(m)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">map[0:Bob]</span><br><span class="line">map[0:map[0:Bob]]</span><br></pre></td></tr></tbody></table></figure>
<h4 id="单独初始化"><a href="#单独初始化" class="headerlink" title="单独初始化"></a>单独初始化</h4><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapF3</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="comment">// 1 : {1:"123"}</span></span><br><span class="line">	m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line">	a, ok := m[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">	fmt.Println(a, ok)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !ok {</span><br><span class="line">		m[<span class="number">0</span>] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>)</span><br><span class="line">	}</span><br><span class="line">	m[<span class="number">0</span>][<span class="number">0</span>] = <span class="string">"OK"</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(m)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"> false</span><br><span class="line">map[0:map[0:OK]]</span><br></pre></td></tr></tbody></table></figure>
<h3 id="循环迭代"><a href="#循环迭代" class="headerlink" title="循环迭代"></a>循环迭代</h3><h4 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h4><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sliceDemo</span><span class="params">()</span></span> {</span><br><span class="line">	a := []<span class="keyword">int</span>{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>}</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> a {</span><br><span class="line">		fmt.Println(i, v)</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">0 1</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">3 4</span><br><span class="line">4 5</span><br><span class="line">5 6</span><br></pre></td></tr></tbody></table></figure>
<p><code>i</code>是索引，<code>v</code>是具体的属性值，v是个拷贝，对其操作不会影响原来的map</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">m := make([]map[int]string, 5)</span><br><span class="line">for _, v := range m {</span><br><span class="line">	v = make(map[int]string, 1)</span><br><span class="line">	v[1] = "OK"</span><br><span class="line">	fmt.Println(v)</span><br><span class="line">}</span><br><span class="line">fmt.Println(m)</span><br></pre></td></tr></tbody></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">map[1:OK]</span><br><span class="line">map[1:OK]</span><br><span class="line">map[1:OK]</span><br><span class="line">map[1:OK]</span><br><span class="line">map[1:OK]</span><br><span class="line">[map[] map[] map[] map[] map[]]</span><br></pre></td></tr></tbody></table></figure>
<p><code>m</code>中并没有<code>"OK"</code>。所以为了影响<code>map</code>中，需要使用到索引，即第一个参数</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapF6</span><span class="params">()</span></span> {</span><br><span class="line">	m := <span class="built_in">make</span>([]<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>, <span class="number">5</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> m {</span><br><span class="line">		m[i] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>, <span class="number">1</span>)</span><br><span class="line">		m[i][<span class="number">1</span>] = <span class="string">"OK"</span></span><br><span class="line">		fmt.Println(m[i])</span><br><span class="line">	}</span><br><span class="line">	fmt.Println(m)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>_</code>为省略</p>
<p>输出</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">map[1:OK]</span><br><span class="line">map[1:OK]</span><br><span class="line">map[1:OK]</span><br><span class="line">map[1:OK]</span><br><span class="line">map[1:OK]</span><br><span class="line">[map[1:OK] map[1:OK] map[1:OK] map[1:OK] map[1:OK]]</span><br></pre></td></tr></tbody></table></figure>
<h4 id="map-1"><a href="#map-1" class="headerlink" title="map"></a>map</h4><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>)</span><br><span class="line">m[<span class="number">0</span>] = <span class="string">"Hello"</span></span><br><span class="line">m[<span class="number">1</span>] = <span class="string">"Jmy"</span></span><br><span class="line">m[<span class="number">2</span>] = <span class="string">"Nice to meet you"</span></span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> m {</span><br><span class="line">   fmt.Println(i, v)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">0 Hello</span><br><span class="line">1 Jmy</span><br><span class="line">2 Nice to meet you</span><br></pre></td></tr></tbody></table></figure>
<p>对<code>map</code>中元素进行操作</p>
<figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">for i, v := range m {</span><br><span class="line"><span class="addition">+	m[i] = v + " 123"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">map[0:Hello 123 1:Jmy 123 2:Nice to meet you 123]</span><br></pre></td></tr></tbody></table></figure>
<h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><h5 id="无序性"><a href="#无序性" class="headerlink" title="无序性"></a>无序性</h5><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapF7</span><span class="params">()</span></span> {</span><br><span class="line">   m := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>{<span class="number">1</span>: <span class="string">"a"</span>, <span class="number">2</span>: <span class="string">"b"</span>, <span class="number">3</span>: <span class="string">"c"</span>, <span class="number">4</span>: <span class="string">"d"</span>, <span class="number">5</span>: <span class="string">"e"</span>}</span><br><span class="line">   s := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="built_in">len</span>(m))</span><br><span class="line">   i := <span class="number">0</span></span><br><span class="line">   <span class="keyword">for</span> key,_ := <span class="keyword">range</span> m{</span><br><span class="line">      s[i] = key</span><br><span class="line">      i ++</span><br><span class="line">   }</span><br><span class="line">   fmt.Println(s)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[5 1 2 3 4]</span><br></pre></td></tr></tbody></table></figure>
<h5 id="sort-包"><a href="#sort-包" class="headerlink" title="sort 包"></a>sort 包</h5><figure class="highlight diff"><table><tbody><tr><td class="code"><pre><span class="line">import (</span><br><span class="line">	"fmt"</span><br><span class="line"><span class="addition">+	"sort"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.... 省略</span><br><span class="line"></span><br><span class="line"><span class="addition">+ sort.Ints(s)</span></span><br><span class="line">fmt.Println(s)</span><br></pre></td></tr></tbody></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[1 2 3 4 5]</span><br></pre></td></tr></tbody></table></figure>
<h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapF8</span><span class="params">()</span></span> {</span><br><span class="line">	m1 := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>{<span class="number">1</span>:  <span class="string">"a"</span>, <span class="number">2</span>: <span class="string">"b"</span>, <span class="number">3</span>: <span class="string">"c"</span>}</span><br><span class="line">	m2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>,<span class="built_in">len</span>(m1))</span><br><span class="line">	<span class="keyword">for</span> key,value := <span class="keyword">range</span> m1{</span><br><span class="line">		m2[value] = key</span><br><span class="line">	}</span><br><span class="line">	fmt.Println(m1)</span><br><span class="line">	fmt.Println(m2)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">map[1:a 2:b 3:c]</span><br><span class="line">map[a:1 b:2 c:3]</span><br></pre></td></tr></tbody></table></figure>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
</search>
